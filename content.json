{"meta":{"title":"我的技术博客","subtitle":null,"description":null,"author":"chenhuaxiang","url":"https://chenhx9211.github.io","root":"/"},"pages":[],"posts":[{"title":"js高级之函数柯里化","slug":"js高级之函数柯里化","date":"2017-09-06T13:09:11.000Z","updated":"2019-06-18T15:00:35.121Z","comments":true,"path":"2017/09/06/js高级之函数柯里化/","link":"","permalink":"https://chenhx9211.github.io/2017/09/06/js高级之函数柯里化/","excerpt":"基本概念 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。–翻译自维基百科 简单的说：柯里函数就是只接受一个参数的函数 例子如下： 12345678910function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2); // 3// 假设有一个 curry 函数可以做到柯里化var addCurry = curry(add);addCurry(1)(2); // 3","text":"基本概念 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。–翻译自维基百科 简单的说：柯里函数就是只接受一个参数的函数 例子如下： 12345678910function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2); // 3// 假设有一个 curry 函数可以做到柯里化var addCurry = curry(add);addCurry(1)(2); // 3 用途和特点 参数复用 - 复用最初函数的第一个参数 提前返回 – 返回接受余下的参数且返回结果的新函数 延迟执行 – 返回新函数，等待执行 函数柯里化的简单实现step1: Generally speaking ，如果三个数求和的函数我们会这样写： 123function _sum3(x, y, z) &#123; return x + y + z;&#125; step2: 如果只考虑实现这个函数的柯里化，我们可以这样做： 12345678function sum3(x) &#123; return function(y) &#123; return function(z) &#123; return x + y + z; &#125;; &#125;;&#125;console.log(sum3(1)(2)(3)); // 6 step4: 观察上面两种不同的写法可以发现，第二种写法其实就是首先把三个参数收集起来，然后到最后再调用第一种写法的函数： 12345678function sum3(x) &#123; return function(y) &#123; return function(z) &#123; return _sum3(x, y, z); &#125;; &#125;;&#125;console.log(sum3(1)(2)(3)); // 6 step5: 所以柯里化的写法只是把常用写法包装了一下，可以使用一个专用的柯里化函数实现这种包装。柯里化函数是一种高阶函数，我们把它命名为 curry 1234567891011function curry(fn) &#123; return function(y) &#123; return function(z) &#123; return fn(x, y, z); &#125;; &#125;;&#125;var sum3 = curry((x, y, z) =&gt; &#123; return x + y + z;&#125;);console.log(sum3(1)(2)(3)); // 6 step6: 如果有要写一种更加通用的，可以柯里化拥有任意多个参数的函数呢，比如 sumN(1)(2)(3)…(N)，按照之前的写法，大概是这个样子的： 123456789101112function curryN(fn) &#123; return function(a1) &#123; return function(a2) &#123; return function(a3) &#123; //...... return function(aN) &#123; return fn(a1, a2, a3, ...aN); &#125;; &#125;; &#125;; &#125;;&#125; step7: 很容易想到可以用一个递归函数来简化这种写法，将上面那些看起来相似的函数结构命名为 nest，就可以写为： 12345678function nest(fn) &#123; return function(x) &#123; return nest(fn); &#125;;&#125;function curry(fn) &#123; nest(fn);&#125; step8: 这里缺少一个循环终止的判断，所以 nest 函数先引入一个新参数 i，当 i === N 时递归终止 1234567891011function nest(fn, i) &#123; return function(x) &#123; if (i === N) &#123; return fn(...) &#125; return nest(fn, i + 1) &#125;&#125;function curry(fn) &#123; return nest(fn, 1)&#125; step9: 接着，需要一个存放任意多个参数的数组，将这个数组命名为 args，然后传入 nest 函数 12345678910111213function nest(fn, i, args) &#123; return function(x) &#123; args.push(x); if (i === fn.length) &#123; return fn(...args); &#125; return nest(fn, i + 1, args); &#125;;&#125;function curry(fn) &#123; const args = []; return nest(fn, 1, args);&#125; step10: 最后在添加一个处理 0 个参数的情况，我们就完成了最终版的柯里化函数 1234567function curry(fn) &#123; if (fn.length === 0) &#123; return fn; &#125; const args = []; return nest(fn, 1, args);&#125; 小试牛刀一下！ 1234const log1 = curry(x =&gt; console.log(x));log1(10); // 10const mul3 = curry((x, y, z) =&gt; console.log(x * y * z));mul3(2)(3)(4); // 24","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chenhx9211.github.io/categories/javascript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://chenhx9211.github.io/tags/es6/"}]},{"title":"redux","slug":"redux","date":"2017-04-13T02:13:26.000Z","updated":"2019-06-18T13:44:56.601Z","comments":true,"path":"2017/04/13/redux/","link":"","permalink":"https://chenhx9211.github.io/2017/04/13/redux/","excerpt":"我学习 redux 的心得： 1.单一的状态树，单向数据流 2.整个项目只有一个 store","text":"我学习 redux 的心得： 1.单一的状态树，单向数据流 2.整个项目只有一个 store 3.由用户发出一个 action，reducer 方法接收这个方法和一个老的 state，再重新返回一个新 state,视图再更新 4.在开发的时候一般会把很多个 reducer 用 redux 里面的 combineReducers 方法合并在一个，便于管理","categories":[{"name":"redux","slug":"redux","permalink":"https://chenhx9211.github.io/categories/redux/"}],"tags":[{"name":"redux","slug":"redux","permalink":"https://chenhx9211.github.io/tags/redux/"}]},{"title":"es6","slug":"es6","date":"2017-04-12T10:54:22.000Z","updated":"2019-06-18T10:39:43.596Z","comments":true,"path":"2017/04/12/es6/","link":"","permalink":"https://chenhx9211.github.io/2017/04/12/es6/","excerpt":"先说一下 let 吧！ let 和 var 一样用来声明变量，但是不同的是：let 命令只在所在的代码块内有效(es5 没有块级作用域) for 循环里面不要再用 var 了，要不然每次输出来的都是最后一个遍历出来的值 let 不存在变量提升，一定要先声明后使用，要不然报错；而 var 可以先使用再声明，输出来 undefined 暂时性死区，只要进去作用域，所要使用的变量就已经存在了，但是不可以获取，只有等到变量声明了才可以获取和使用它 let 不允许在同一作用域内重复声明","text":"先说一下 let 吧！ let 和 var 一样用来声明变量，但是不同的是：let 命令只在所在的代码块内有效(es5 没有块级作用域) for 循环里面不要再用 var 了，要不然每次输出来的都是最后一个遍历出来的值 let 不存在变量提升，一定要先声明后使用，要不然报错；而 var 可以先使用再声明，输出来 undefined 暂时性死区，只要进去作用域，所要使用的变量就已经存在了，但是不可以获取，只有等到变量声明了才可以获取和使用它 let 不允许在同一作用域内重复声明 为什么需要块级作用域呢？@内层变量可能会覆盖外层变量@用来计数的循环变量泄露为全局变量，很容易造成内存泄漏 下面再说说 const! 用来声明常量，所以一旦声明变量，就必须立即初始化，不能留到以后赋值，只声明不赋值，就会报错 const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效 const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用 const 声明的常量，也与 let 一样不可重复声明 结构先不说，比较简单，主要分为数组，对象，字符串，数值，布尔值，函数参数解构看了一圈下来，关键是用途，总结一下： 交换变量的值 从函数返回多个值 函数参数的定义 提取 json 数据(我认为这个比较实用，拿出来可以直接放到视图) 遍历 Map 结构 字符串的扩展(下面几个是我认为能用到项目里面频率相对高的) Unicode 表示法：eg:\\u{1F680} 遍历接口器，可以把字符串的每一个字符都遍历出来 123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// \"f\"// \"o\"// \"o\" at(),这个和 es5 的 charAt()差不多，并且能识别出来码点大于 0xFFFF 的字符 includes(),startsWith(),endsWith(),he es5 的 indexOf 方法差不多，它返回的是布尔值 12345var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true repeat()直接看下面的代码吧 123'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\" 注意：如果是小数，则取整；负数或者 Infinity，报错；0 到-1 的都视为 0；NaN 视为 0","categories":[{"name":"es6","slug":"es6","permalink":"https://chenhx9211.github.io/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://chenhx9211.github.io/tags/es6/"}]},{"title":"基于vue vuex es6 webpack的项目","slug":"基于vue vuex es6 webpack的项目","date":"2017-04-11T13:46:37.000Z","updated":"2019-06-18T10:40:23.215Z","comments":true,"path":"2017/04/11/基于vue vuex es6 webpack的项目/","link":"","permalink":"https://chenhx9211.github.io/2017/04/11/基于vue vuex es6 webpack的项目/","excerpt":"一个基于 vue+vuex+es6+webpack 技术栈的 spa 开店项目","text":"一个基于 vue+vuex+es6+webpack 技术栈的 spa 开店项目 使用了 vue-router 来做页面的路由跳转，主页跳转至详情页面使用具体路由的配置。 整个项目使用的是 es6 的语法我比较喜欢 es6 的语法，arrow function，let,const,template string，解构,尤其是在 react 里面比较喜欢用的 class,extends,super。 状态管理用 vuex 使用 axios 从后端获取数据 对啦，项目使用的脚手架 vue-cli,快速上手 github 地址：https://github.com/chenhx9211/vue-onlineStore","categories":[{"name":"vue","slug":"vue","permalink":"https://chenhx9211.github.io/categories/vue/"}],"tags":[{"name":"vue vuex","slug":"vue-vuex","permalink":"https://chenhx9211.github.io/tags/vue-vuex/"}]},{"title":"react-native 常用的布局：flexbox","slug":"layout","date":"2017-04-10T06:09:14.000Z","updated":"2019-06-18T13:01:19.148Z","comments":true,"path":"2017/04/10/layout/","link":"","permalink":"https://chenhx9211.github.io/2017/04/10/layout/","excerpt":"基本概念 采用 flex 布局的元素就是 flex 容器：flex container.它里面所有的元素都叫子元素：flex item. container 容器存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis).主轴起始位置 main start,结束位置 main end,交叉轴起始位置 cross start,结束位置 cross end. 3.项目默认沿着主轴排列.","text":"基本概念 采用 flex 布局的元素就是 flex 容器：flex container.它里面所有的元素都叫子元素：flex item. container 容器存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis).主轴起始位置 main start,结束位置 main end,交叉轴起始位置 cross start,结束位置 cross end. 3.项目默认沿着主轴排列. container 上设置的属性有 6 个 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction:主轴的方向123.box&#123; flex-direction:row | row-reverse | column | column-reverse;&#125; flex-wrap:如果一条轴线排不下，如何换行123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 1.nowrap:不换行2.wrap：换行，第一行在上方3.wrap-reverse：换行，第一行在下方 flex-flow：是 flex-direction 和 flex-wrap 的简写justify-content：项目在主轴上的对齐方式123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 align-items：项目在交叉轴上如何对齐123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch：如果项目未设置高度或设为 auto，将占满整个容器的高度(默认值) align-content:定义了多根轴线的对齐方式.如果项目只有一根轴线，该属性不起作用123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; item 上设置的属性有 6 个 order flex-grow flex-shrink flex-basis flex align-self order:定义项目的排列顺序.数值越小，排列越靠前，默认为 0.123.item &#123; order: &lt;integer&gt;;&#125; flex-grow:定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大.注意：如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小.注意：如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）.注意：它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flex：是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选.align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性.默认值为 auto.123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 好啦,到此结束！ 注意事项 任何一个元素都可以使用 flex 布局，行内元素使用 display:inline-flex; webkit 内核的浏览器必须加上-webkit 前缀：display：-webkit-flex; 设置 flex 布局以后，子元素的这三个属性将会失效:float,clear,vertical-align.","categories":[{"name":"css","slug":"css","permalink":"https://chenhx9211.github.io/categories/css/"}],"tags":[{"name":"flex","slug":"flex","permalink":"https://chenhx9211.github.io/tags/flex/"}]},{"title":"js设计模式之观察者模式","slug":"js设计模式之观察者模式","date":"2016-02-17T03:29:07.000Z","updated":"2019-06-18T15:36:41.545Z","comments":true,"path":"2016/02/17/js设计模式之观察者模式/","link":"","permalink":"https://chenhx9211.github.io/2016/02/17/js设计模式之观察者模式/","excerpt":"","text":"","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chenhx9211.github.io/categories/javascript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://chenhx9211.github.io/tags/es6/"}]}]}