{"meta":{"title":"我的技术博客","subtitle":null,"description":null,"author":"chenhuaxiang","url":"https://chenhx9211.github.io","root":"/"},"pages":[],"posts":[{"title":"基于vue vuex es6 webpack的项目","slug":"基于vue vuex es6 webpack的项目","date":"2019-06-18T05:46:40.396Z","updated":"2019-06-19T11:21:48.954Z","comments":true,"path":"2019/06/18/基于vue vuex es6 webpack的项目/","link":"","permalink":"https://chenhx9211.github.io/2019/06/18/基于vue vuex es6 webpack的项目/","excerpt":"一个基于 vue+vuex+es6+webpack 技术栈的 spa 开店项目","text":"一个基于 vue+vuex+es6+webpack 技术栈的 spa 开店项目 使用了 vue-router 来做页面的路由跳转，主页跳转至详情页面使用具体路由的配置。 整个项目使用的是 es6 的语法我比较喜欢 es6 的语法，arrow function，let,const,template string，解构,尤其是在 react 里面比较喜欢用的 class,extends,super。 状态管理用 vuex 使用 axios 从后端获取数据 对啦，项目使用的脚手架 vue-cli,快速上手 github 地址：https://github.com/chenhx9211/vue-onlineStore","categories":[{"name":"vue","slug":"vue","permalink":"https://chenhx9211.github.io/categories/vue/"}],"tags":[{"name":"vue vuex","slug":"vue-vuex","permalink":"https://chenhx9211.github.io/tags/vue-vuex/"}]},{"title":"redux","slug":"redux","date":"2018-04-13T02:13:26.000Z","updated":"2019-06-19T08:00:56.698Z","comments":true,"path":"2018/04/13/redux/","link":"","permalink":"https://chenhx9211.github.io/2018/04/13/redux/","excerpt":"我学习 redux 的心得： 1.单一的状态树，单向数据流 2.整个项目只有一个 store","text":"我学习 redux 的心得： 1.单一的状态树，单向数据流 2.整个项目只有一个 store 3.由用户发出一个 action，reducer 方法接收这个方法和一个老的 state，再重新返回一个新 state,视图再更新 4.在开发的时候一般会把很多个 reducer 用 redux 里面的 combineReducers 方法合并在一个，便于管理","categories":[{"name":"redux","slug":"redux","permalink":"https://chenhx9211.github.io/categories/redux/"}],"tags":[{"name":"redux","slug":"redux","permalink":"https://chenhx9211.github.io/tags/redux/"}]},{"title":"es6","slug":"es6","date":"2018-04-12T10:54:22.000Z","updated":"2019-06-19T09:17:10.534Z","comments":true,"path":"2018/04/12/es6/","link":"","permalink":"https://chenhx9211.github.io/2018/04/12/es6/","excerpt":"先说一下 let 吧！ let 和 var 一样用来声明变量，但是不同的是：let 命令只在所在的代码块内有效(es5 没有块级作用域) for 循环里面不要再用 var 了，要不然每次输出来的都是最后一个遍历出来的值 let 不存在变量提升，一定要先声明后使用，要不然报错；而 var 可以先使用再声明，输出来 undefined 暂时性死区，只要进去作用域，所要使用的变量就已经存在了，但是不可以获取，只有等到变量声明了才可以获取和使用它 let 不允许在同一作用域内重复声明","text":"先说一下 let 吧！ let 和 var 一样用来声明变量，但是不同的是：let 命令只在所在的代码块内有效(es5 没有块级作用域) for 循环里面不要再用 var 了，要不然每次输出来的都是最后一个遍历出来的值 let 不存在变量提升，一定要先声明后使用，要不然报错；而 var 可以先使用再声明，输出来 undefined 暂时性死区，只要进去作用域，所要使用的变量就已经存在了，但是不可以获取，只有等到变量声明了才可以获取和使用它 let 不允许在同一作用域内重复声明 为什么需要块级作用域呢？@内层变量可能会覆盖外层变量@用来计数的循环变量泄露为全局变量，很容易造成内存泄漏 下面再说说 const! 用来声明常量，所以一旦声明变量，就必须立即初始化，不能留到以后赋值，只声明不赋值，就会报错 const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效 const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用 const 声明的常量，也与 let 一样不可重复声明 结构先不说，比较简单，主要分为数组，对象，字符串，数值，布尔值，函数参数解构看了一圈下来，关键是用途，总结一下： 交换变量的值 从函数返回多个值 函数参数的定义 提取 json 数据(我认为这个比较实用，拿出来可以直接放到视图) 遍历 Map 结构 字符串的扩展(下面几个是我认为能用到项目里面频率相对高的) Unicode 表示法：eg:\\u{1F680} 遍历接口器，可以把字符串的每一个字符都遍历出来 123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// \"f\"// \"o\"// \"o\" at(),这个和 es5 的 charAt()差不多，并且能识别出来码点大于 0xFFFF 的字符 includes(),startsWith(),endsWith(),he es5 的 indexOf 方法差不多，它返回的是布尔值 12345var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true repeat()直接看下面的代码吧 123'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\" 注意：如果是小数，则取整；负数或者 Infinity，报错；0 到-1 的都视为 0；NaN 视为 0","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chenhx9211.github.io/categories/javascript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://chenhx9211.github.io/tags/es6/"}]},{"title":"Web站点加速最佳实践","slug":"Best Practices for Speeding Up Your Web Site","date":"2017-11-08T03:29:07.000Z","updated":"2019-06-19T09:11:19.277Z","comments":true,"path":"2017/11/08/Best Practices for Speeding Up Your Web Site/","link":"","permalink":"https://chenhx9211.github.io/2017/11/08/Best Practices for Speeding Up Your Web Site/","excerpt":"&emsp;&emsp;在高性能 Web 建设指南摘要总结了前端性能优化的 14 条原则，在高性能 Web 进阶指南中，也由一些建议。几年过去了，Yahoo 的 Exceptional Performance team 总结的规则也发展到 35 条。原文地址。规则分为七类：页面内容，服务器，cookie，css，javascript，图片和手机端。&emsp;&emsp; 根据原文翻译整理了一下，记录了一些新的原则。感谢前端工具的发展，如 webpack，eslint，其中很多优化原则都可以让工具自动实施。其中原来的黄金规则可参看高性能 Web 建设指南摘要","text":"&emsp;&emsp;在高性能 Web 建设指南摘要总结了前端性能优化的 14 条原则，在高性能 Web 进阶指南中，也由一些建议。几年过去了，Yahoo 的 Exceptional Performance team 总结的规则也发展到 35 条。原文地址。规则分为七类：页面内容，服务器，cookie，css，javascript，图片和手机端。&emsp;&emsp; 根据原文翻译整理了一下，记录了一些新的原则。感谢前端工具的发展，如 webpack，eslint，其中很多优化原则都可以让工具自动实施。其中原来的黄金规则可参看高性能 Web 建设指南摘要 内容减少 DOM 元素数量&emsp;&emsp; 检查文档 dom 数量的简单办法，在浏览器控制台运行下一行代码:document.getElementsByTagName(‘*‘).length 尽量减少使用 iframeiframe 帮助第三方内容嵌入，帮助脚本并行下载，但是使用它的代价很大，它会阻塞页面加载 不使用 404一个无用的响应(例如 404 Not Found) 完全没有用处，只会降低用户体验。有些站点使用诸如”Did you mean X?”的 404 响应, 对用户体验有帮助但是浪费了服务器资源(例如数据库等). 如果链接是一个外部的脚本，而返回的响应是 404，尤其糟糕：首先, 脚本下载会阻塞并行下载，其次如果 404 响应的 body 是 JavaScript 代码，浏览器会去解析脚本。 服务器Flush the Buffer EarlyWhen users request a page, it can take anywhere from 200 to 500ms for the backend server to stitch together the HTML page. During this time, the browser is idle as it waits for the data to arrive. In PHP you have the function flush(). It allows you to send your partially ready HTML response to the browser so that the browser can start fetching components while your backend is busy with the rest of the HTML page. The benefit is mainly seen on busy backends or light frontends. A good place to consider flushing is right after the HEAD because the HTML for the head is usually easier to produce and it allows you to include any CSS and JavaScript files for the browser to start fetching in parallel while the backend is still processing. Example: ... &lt;!-- css, js --&gt; &lt;/head&gt; &lt;?php flush(); ?&gt; &lt;body&gt; ... &lt;!-- content --&gt;Use GET for AJAX RequestsThe Yahoo! Mail team found that when using XMLHttpRequest, POST is implemented in the browsers as a two-step process: sending the headers first, then sending data. So it’s best to use GET, which only takes one TCP packet to send (unless you have a lot of cookies). The maximum URL length in IE is 2K, so if you send more than 2K data you might not be able to use GET. An interesting side affect is that POST without actually posting any data behaves like GET. Based on the HTTP specs, GET is meant for retrieving information, so it makes sense (semantically) to use GET when you’re only requesting data, as opposed to sending data to be stored server-side. 避免 Image 元素的 src 属性为空无论是 html 代码中的&lt;img src=&quot;&quot;&gt;或是通过 JavaScript 12var img = new Image();img.src = &quot;&quot;; 都导致同样结果: 浏览器多发出一个 http 请求： Internet Explorer 会请求页面目录 Safari 和 Chrome 会请求页面. Firefox 3 以及之前的版本如同 Safari 和 Chrome, 不过 3.5 不再发出请求. Opera 不会发出请求. Why is this behavior bad? Cripple your servers by sending a large amount of unexpected traffic, especially for pages that get millions of page views per day.Waste server computing cycles generating a page that will never be viewed.Possibly corrupt user data. If you are tracking state in the request, either by cookies or in another way, you have the possibility of destroying data. Even though the image request does not return an image, all of the headers are read and accepted by the browser, including all cookies. While the rest of the response is thrown away, the damage may already be done. HTML5 增加了对 to the description of the tag’s src attribute to instruct browsers not to make an additional request The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string.Hopefully, browsers will not have this problem in the future. Unfortunately, there is no such clause for &lt;script src=&quot;&quot;&gt; and &lt;link href=&quot;&quot;&gt; Maybe there is still time to make that adjustment to ensure browsers don’t accidentally implement this behavior.This rule was inspired by Yahoo!’s JavaScript guru Nicolas C. Zakas. For more information check out his article “Empty image src can destroy your site”. Cookie减少 Cookie 大小静态内容使用 Cookie-free 域名&emsp;&emsp; 浏览器请求静态图片等内容时候，Web 服务器一般并不使用 Cookie。因此，静态内容的主机名称使用 cookie-free 域名，浏览器就不会发送 cookie，可减少网络流量。 避免使用 CSS Filter&emsp;&emsp; The IE-proprietary AlphaImageLoader filter aims to fix a problem with semi-transparent true color PNGs in IE versions &lt; 7. The problem with this filter is that it blocks rendering and freezes the browser while the image is being downloaded. It also increases memory consumption and is applied per element, not per image, so the problem is multiplied. &emsp;&emsp; The best approach is to avoid AlphaImageLoader completely and use gracefully degrading PNG8 instead, which are fine in IE. If you absolutely need AlphaImageLoader, use the underscore hack _filter as to not penalize your IE7+ users. Choose over @import&emsp;&emsp; One of the previous best practices states that CSS should be at the top in order to allow for progressive rendering. &emsp;&emsp; In IE @import behaves the same as using at the bottom of the page, so it’s best not to use it. JavascriptMinimize DOM Access&emsp;&emsp; Accessing DOM elements with JavaScript is slow so in order to have a more responsive page, you should: Cache references to accessed elementsUpdate nodes “offline” and then add them to the treeAvoid fixing layout with JavaScriptFor more information check the YUI theatre’s “High Performance Ajax Applications” by Julien Lecomte. Develop Smart Event Handlers&emsp;&emsp; Sometimes pages feel less responsive because of too many event handlers attached to different elements of the DOM tree which are then executed too often. That’s why using event delegation is a good approach. If you have 10 buttons inside a div, attach only one event handler to the div wrapper, instead of one handler for each button. Events bubble up so you’ll be able to catch the event and figure out which button it originated from. You also don’t need to wait for the onload event in order to start doing something with the DOM tree. Often all you need is the element you want to access to be available in the tree. You don’t have to wait for all images to be downloaded. DOMContentLoaded is the event you might consider using instead of onload, but until it’s available in all browsers, you can use the YUI Event utility, which has an onAvailable method. 图片Optimize CSS SpritesArranging the images in the sprite horizontally as opposed to vertically usually results in a smaller file size.Combining similar colors in a sprite helps you keep the color count low, ideally under 256 colors so to fit in a PNG8.“Be mobile-friendly” and don’t leave big gaps between the images in a sprite. This doesn’t affect the file size as much but requires less memory for the user agent to decompress the image into a pixel map. 100x100 image is 10 thousand pixels, where 1000x1000 is 1 million pixels 不要在 HTML 中缩放图片&emsp;&emsp; 例如 1&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; &emsp;&emsp; 图片 mycat.jpg 就应该是 100x100px，而不是一个 500x500px. favicon.ico&emsp;&emsp;浏览器每次访问网站，都会自动请求，因此最好是在根目录创建一个 favicon.ico，同时尽可能缓存 尽量小于 1K. 设置 Expires 头 手机端组件(译者注：指的是 html 页面，css，js，图片等等页面内容文件)的大小不要超过 25KiPhone 不会缓冲大于 25K 的内容。 值得注意的是 25k 是指解压后的文件大小，单独使用 gzip 不起作用，因此减少文件的大小很重要。 详情可参看 Wayne Shea 和 Tenni Theurer 写的“Performance Research, Part 5: iPhone Cacheability - Making it Stick”. Pack Components into a Multipart Document把内容组件打包到一个 multipart 文档，就像带附件的电子邮件, 有助于使用一次 HTTP 请求，获取多个内容组件。使用这个技巧前, 首先检查一下客户端的 user agent 是否支持(iPhone 不支持)。","categories":[{"name":"frontend","slug":"frontend","permalink":"https://chenhx9211.github.io/categories/frontend/"}],"tags":[{"name":"前端性能","slug":"前端性能","permalink":"https://chenhx9211.github.io/tags/前端性能/"}]},{"title":"高性能Web进阶指南摘要","slug":"高性能Web进阶指南摘要","date":"2017-09-23T13:09:11.000Z","updated":"2019-06-19T10:25:24.327Z","comments":true,"path":"2017/09/23/高性能Web进阶指南摘要/","link":"","permalink":"https://chenhx9211.github.io/2017/09/23/高性能Web进阶指南摘要/","excerpt":"&emsp;&emsp;本书大部分内容讲 JavsScript 的性能优化，图片和 CSS 的处理也涉及到一些，也涉及到一些服务器端的处理。里面的内容讲得很好，不过鉴于近期的前端框架和工具的成熟，里面绝大内容都由框架和工具自动处理了，就没有摘录。写在这里，不过是为看过这本书做个记录。","text":"&emsp;&emsp;本书大部分内容讲 JavsScript 的性能优化，图片和 CSS 的处理也涉及到一些，也涉及到一些服务器端的处理。里面的内容讲得很好，不过鉴于近期的前端框架和工具的成熟，里面绝大内容都由框架和工具自动处理了，就没有摘录。写在这里，不过是为看过这本书做个记录。","categories":[{"name":"frontend","slug":"frontend","permalink":"https://chenhx9211.github.io/categories/frontend/"}],"tags":[{"name":"前端性能","slug":"前端性能","permalink":"https://chenhx9211.github.io/tags/前端性能/"}]},{"title":"执行上下文和作用域链","slug":"执行上下文和作用域链","date":"2017-09-06T13:09:11.000Z","updated":"2019-06-19T14:14:37.759Z","comments":true,"path":"2017/09/06/执行上下文和作用域链/","link":"","permalink":"https://chenhx9211.github.io/2017/09/06/执行上下文和作用域链/","excerpt":"执行上下文&emsp;&emsp;JavaScript 引擎执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。JavaScript 引擎创建执行上下文栈（Execution context stack，ECStack）来管理执行上下文。","text":"执行上下文&emsp;&emsp;JavaScript 引擎执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。JavaScript 引擎创建执行上下文栈（Execution context stack，ECStack）来管理执行上下文。 &emsp;&emsp;JavaScript 引擎 开始要解释执行代码的时候，最先遇到的就是全局代码，初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：&emsp;&emsp;执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。 看一个《JavaScript 权威指南》中的例子： 123456789var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码执行的结果一样，但是两段代码的是执行上下文栈的变化不一样。 第一段代码的执行过程模拟： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 第二段代码的执行过程模拟： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 作用域&emsp;&emsp;作用域是指程序代码中定义变量的区域，它规定了如何查找变量。 一个变量写在函数中，和写在函数外，它的作用域是不同的，也就是所谓局部变量和全局变量。&emsp;&emsp;在编程语言的设计中，有两种作用域设计方式：静态作用域与动态作用域。JavaScript 采用的是静态作用域。 静态作用域，也叫词法作用域(lexical scoping)，函数的作用域在函数定义的时候就决定了。 动态作用域，函数的作用域是在函数调用的时候才决定的。 &emsp;&emsp;举看个例子来说明它们直接的之间的区别： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? &emsp;&emsp;假设 JavaScript 采用静态作用域， foo 函数的执行，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据定义的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 &emsp;&emsp;假设 JavaScript 采用动态作用域，foo 函数的执行，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用 foo()的位置所在的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 &emsp;&emsp;JavaScript 采用的是静态作用域，这个例子的结果是 1。 作用域链每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO)，包含了全部的局部变量 作用域链(Scope chain) this &emsp;&emsp;JavaScript 代码执行时，先从当前上下文中查找变量，如果没有找到，就从父级(词法层面上的父级)执行上下文的变量对象 VO 中查找，一直找到全局上下文的变量对象，也就是全局对象。这样，多个执行上下文的变量对象就构成一个链表，叫做作用域链。&emsp;&emsp;和作用域一样，JavaScript 函数的作用域链是在函数定义的时候创建的。当函数创建的时候，有一个内部属性 [[scope]]，会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链。举个例子： 123456function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为： 123456789foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; &emsp;&emsp;但是[[scope]] 并不代表完整的作用域链。当函数执行时，创建活动对象 AO；再将活动对象 AO 添加到作用链的前端。这时候执行上下文的作用域链，才是完整的，我们命名为 Scope： 1Scope = [AO].concat([[Scope]]); 结合 ECStack，再来看看上面的列出的《JavaScript 权威指南》中例子的第一段代码： 123456789var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f();&#125;checkscope(); 执行过程如下： 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 1ECStack = [globalContext]; 全局上下文初始化 12345globalContext = &#123; VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO&#125;; checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1ECStack = [checkscopeContext, globalContext]; 初始化 checkscope 函数执行上下文： 复制函数 [[scope]] 属性创建作用域链， 123checkscopeContext = &#123; Scope: checkscope.[[scope]],&#125; 用 arguments 创建活动对象 初始化活动对象，加入形参、函数声明、变量声明 12345678checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined &#125;&#125;; 将活动对象压入 checkscope 作用域链顶端。 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined &#125;, Scope: [AO, [[Scope]]]&#125;; 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 开始执行函数，随着函数的执行，修改 AO 的属性值，AO 中的 scope 被赋值”local scope” 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: \"local scope\" &#125;, Scope: [AO, [[Scope]]]&#125;; 执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 1ECStack = [fContext, checkscopeContext, globalContext]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125;; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1ECStack = [checkscopeContext, globalContext]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 1ECStack = [globalContext]; 同样可分析第二段代码： 123456789var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f;&#125;checkscope()();","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chenhx9211.github.io/categories/javascript/"}],"tags":[]},{"title":"闭包","slug":"闭包","date":"2017-09-06T13:09:11.000Z","updated":"2019-06-19T14:35:32.985Z","comments":true,"path":"2017/09/06/闭包/","link":"","permalink":"https://chenhx9211.github.io/2017/09/06/闭包/","excerpt":"闭包 = 函数 + 函数能够访问的自由变量","text":"闭包 = 函数 + 函数能够访问的自由变量 自由变量&emsp;&emsp;自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量，也称为未绑定变量(unbound)。相对而言，参数和局部变量就是绑定变量。 &emsp;&emsp;举个例子： 1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); &emsp;&emsp;foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 闭包(closure)&emsp;&emsp;了解了自由变量，闭包的定义就很好理解：闭包是指那些能够访问自由变量的函数。&emsp;&emsp;从理论角度：所有的 JavaScript 函数都是闭包。因为它们都在创建的时候就将上层上下文的数据保存起来了, 在函数中访问全局变量就相当于是在访问自由变量。&emsp;&emsp;从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 &emsp;&emsp;JavaScript 权威指南对闭包的定义是:&emsp;&emsp;闭包就是一个函数对象和一个作用域(scope, a set of variable bindings，在这个作用域中，该函数的所有变量都能查找到)的结合， 分析&emsp;&emsp;当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 来自《JavaScript 权威指南》的例子： 1234567891011var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); &emsp;&emsp;分析一下这段代码中执行上下文栈和执行上下文的变化情况。 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this 等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this 等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 &emsp;&emsp;当 f 函数执行的时候，checkscope 函数上下文已经从执行上下文栈中被弹出被销毁，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO]&#125;; &emsp;&emsp;即使 checkscopeContext 被销毁了，当 f 函数引用了 checkscopeContext.VO 中的值的时候， JavaScript 依然会让 checkscopeContext.VO 保持在内存中，f 函数依然可以通过 f 函数的作用域链找到它，实现了闭包。 面试必考的闭包题： 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function() &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 改成下面的代码看看： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function(i) &#123; return function() &#123; console.log(i); &#125;; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO, globalContext.VO]&#125; 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125;; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为 3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chenhx9211.github.io/categories/javascript/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"https://chenhx9211.github.io/tags/闭包/"}]},{"title":"高性能Web建设指南摘要","slug":"高性能Web建设指南摘要","date":"2017-09-06T13:09:11.000Z","updated":"2019-06-19T08:05:16.171Z","comments":true,"path":"2017/09/06/高性能Web建设指南摘要/","link":"","permalink":"https://chenhx9211.github.io/2017/09/06/高性能Web建设指南摘要/","excerpt":"&emsp;&emsp;性能黄金法则：10 ～ 20%的总响应时间在下载 html 文档，80 ～ 90%的时间在下载页面中的组件(图片，外部样式表、脚本等)。优化的要点是减少占比达 80 ～ 90%页面组件响应时间。","text":"&emsp;&emsp;性能黄金法则：10 ～ 20%的总响应时间在下载 html 文档，80 ～ 90%的时间在下载页面中的组件(图片，外部样式表、脚本等)。优化的要点是减少占比达 80 ～ 90%页面组件响应时间。 规则 1–减少 HTTP 请求运用以下技术减少 http 请求 图片地图 CSS Sprites 内联图片 合并样式表 合并脚本 规则 2–使用内容分发网络&emsp;&emsp;内容分布网络(CDN)是一组分布在多个不同地理位置的 Web 服务器。静态内容组件发布到 CDN 后，会在多个 Web 服务器都有拷贝，当用户请求内容组件时，CDN 可选择响应时间最短的 Web 服务器(比如离用户最近的服务器)来完成请求。 &emsp;&emsp;CDN 不但带来更短的响应时间，而且可以缓解自身服务器的压力。 规则 3–添加 EXpires 头&emsp;&emsp;http 数据包分为头(head)和身体(body)两部分，头部可添加 Expires 和 Cache-Control 来影响浏览器的缓存时间。有两种方法可以设置 http 头 服务器端在响应请求时设置请求的 http 头。 html 页面通过 meta 标签的 http-equiv 来设定。 12＜meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2007 22:33:00 GMT&quot;＞＜meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=7200&quot;＞ &emsp;&emsp;http-equiv 相当于 http 的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容。http-equiv 对应的属性值为 content，可设置各个参数的变量值。&emsp;&emsp;客户端(比如 JavaScript 脚本)可以在 HTTP 请求中使用的标准 Cache-Control 指令 Cache-Control: max-age=&lt;seconds&gt; Cache-Control: max-stale[=&lt;seconds&gt; Cache-Control: min-fresh=&lt;seconds&gt; Cache-control: no-cache Cache-control: no-store Cache-control: no-transform Cache-control: only-if-cached &emsp;&emsp;服务器可以在响应中使用的标准 Cache-Control 指令 Cache-control: must-revalidate Cache-control: no-cache Cache-control: no-store Cache-control: no-transform Cache-control: public Cache-control: private Cache-control: proxy-revalidate Cache-Control: max-age=&lt;seconds&gt; Cache-control: s-maxage=&lt;seconds&gt; 规则 4–压缩组件Web 客户端可在 http 请求的头部中加入 Accept-Encoding 来标识客户端支持的压缩方法类型（浏览器一般会自动在每次的请求中加入这个头部指令），Web 服务器会用客户端列出来的方法之一来压缩响应结果，并在响应中加入 Content-Encoding:xxx. 最常用的压缩方法是 gzip。 存在代理和 CDN 的情况会变复杂，解决办法是在服务器的响应头部中加入 Vary: Accept-Encoding 规则 5–将样式表放在文档顶部&emsp;&emsp;浏览器一般会逐步呈现已下载的内容，样式表放在文档底部时，为避免当样式变化时重绘页面中的元素，浏览器会延迟显示任何可视化组件。样式表的放置在底部不会影响下载时间，但是会影响内容的逐步呈现，用户会有更慢的感觉，同时它还和白屏、无样式内容的闪烁相关。 规则 6–将脚本放在文档底部&emsp;&emsp;http 1.1 协议建议浏览器从每个主机名下并行的下载两个组件。 然而，下载脚本时实际上会禁用并行下载-即使使用了不同的主机名。其中的原因是： 脚本可能使用 document.write 来修改页面内容，因此浏览器会等待，以确保页面能够恰当的布局。 保证脚本能按正确的顺序执行，如果并行下载多个脚本，页面次序中在后的脚本有可能先下载完成并执行。 &emsp;&emsp;将脚本放在顶部，会阻塞对其后面内容的呈现，同时阻塞对后面组件的下载。 规则 7–避免 CSS 表达式&emsp;&emsp;CSS expression 方法可接受一个 JavaScript 表达式，很多情况下会导致对其频繁求值，影响浏览器性能。建议使用一次性表达式，或使用 JavaScript 在事件处理中提供动态行为。 规则 8–使用外部 JavaScript 和 CSS&emsp;&emsp;浏览器可以缓存外部 JavaScript 和 CSS，外部的 JavaScript 和 CSS 还可给网站中其他页面共享。 加载后下载同样的样式表或脚本同时写入到外部文件和内联到页面中，在页面的 onload 事件再次下载含有同样内容的外部文件。内联的样式和脚本让页面呈现更快，同时网站的其他页面可使用已下载的外部样式和脚本文件。需要注意脚本和 CSS 加载两次可能带来的问题。 规则 9–减少 DNS 查找&emsp;&emsp;浏览器会解析 html 页面外部组件所使用主机名称，http 1.1 协议建议每个主机名称两个并行下载；因而在 html 页面中对页面中的组件使用多个主机名称，可提高并行下载数量。然而过多的主机名称，可能不能更好的利用 http 1.1 协议的 keep-alive 特性，同时导致浏览器进行多次 DNS 查找。综合两个考虑，建议在页面中使用至少两个，但不要超过 4 个主机名。 规则 10–精简（minify） JavaScript 、 CSS压缩混淆 JavaScript 代码，以减小代码尺寸。同样对 CSS，html 都可使用工具进行 minify。 规则 11–避免重定向一些容易忽视的场景： url 指向目录时，结尾不要省略斜线/，不要让 Web 服务器为你发出重定向 内部流量跟踪，使用 referer 日志跟踪流量取向，而不是使用重定向。 出战流量跟踪，不实用重定向，而使用信标 beancon–一个在 url 中包含有跟踪信息的 http 请求（信标响应通常是一个 1px X 1px 的透明图片；或者使用 204 响应，因为它更小，从来不会被缓存，而且绝对不会改变浏览器状态。），跟踪信息可以从信标的 web 服务器请求日志中提取出来。 &emsp;&emsp;使用图片的信标例子 1234567891011121314151617&lt;a href=&quot;http://en.wikipedia.org/wiki/Performance&quot; onclick=&quot;resultBeacon(this); return false;&quot;&gt;Performance - Wikipedia&lt;/a&gt;&lt;script&gt;var beacon;function resultBeacon(anchor) &#123; beacon = new Image(); beacon.onload = gotoUrl; beacon.onerror = gotoUrl; // in case the image fails, we still want to redirect the user beacon.anchor = anchor; beacon.src = &quot;/bin/beacon204.gif?url=&quot; + escape(anchor.href);&#125;function gotoUrl() &#123; document.location = beacon.anchor.href;&#125;&lt;/script&gt; &emsp;&emsp;使用 XHttpRequest 的信标例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;a href=&quot;http://en.wikipedia.org/wiki/Performance&quot; onclick=&quot;resultBeacon(this); return false;&quot;&gt;Performance - Wikipedia&lt;/a&gt;&lt;script&gt;var gAnchor, gXhrObj;function resultBeacon(anchor) &#123; gAnchor = anchor; beacon_src = &quot;http://stevesouders.com/images/beacon.gif?url=&quot; + escape(anchor.href) + &quot;&amp;t=&quot; + Number(new Date()); gXhrObj = getXHRObject(); gXhrObj.onreadystatechange = xhrCallback; try &#123; gXhrObj.open(&quot;GET&quot;, beacon_src, true); // true == async gXhrObj.send(&quot;&quot;); &#125;catch(err) &#123; gotoUrl(); // on failure, just go to the target url &#125;&#125;function xhrCallback(respAr) &#123; var readyState = ( respAr &amp;&amp; &quot;undefined&quot; != typeof(respAr.readyState) ? respAr.readyState : gXhrObj.readyState ); if ( 2 == readyState ) &#123; // the request is done enough to risk unloading the page gotoUrl(); &#125;&#125;function gotoUrl() &#123; document.location = gAnchor.href;&#125;// Find the right syntax for creating an XHR object.function getXHRObject() &#123; var xhrObj = false; try &#123; xhrObj = new XMLHttpRequest(); &#125;catch(e)&#123; var progid = [&apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;, &apos;Microsoft.XMLHTTP&apos;]; for ( var i=0; i &lt; progid.length; ++i ) &#123; try &#123; xhrObj = new ActiveXObject(progid[i]); &#125;catch(e) &#123; &#125; &#125; &#125; finally &#123; return xhrObj; &#125;&#125;&lt;/script&gt; 规则 12–移除重复脚本&emsp;&emsp;团队规模和脚本数量变大，往往会有相同的脚本代码。需要实现一个脚本管理模块，避免重复的脚本。 规则 13–配置或移除 ETag&emsp;&emsp;ETag，Entity Tag-实体标签是 Web 服务器和浏览器用于确认缓存组件有效性的一种机制。条件 Get 请求会比较文件修改日期和 ETag 标签，ETag 标签对于静态文件而言不利。因此建议是在服务器端配置 ETag 或者干脆移除它。 规则 14–使 AJAX 可缓存&emsp;&emsp;某些 AJAX Get 请求可以被缓存，而不影响用户体验。要使这些 AJAX 请求被缓存，需要 给响应设置 HTTP Cache-Control 或 Expires 头 请求的 URL 中应包括响应的个性化和动态化数据，这样缓存结果才正确的反映出个性化和动态化。","categories":[{"name":"frontend","slug":"frontend","permalink":"https://chenhx9211.github.io/categories/frontend/"}],"tags":[{"name":"前端性能","slug":"前端性能","permalink":"https://chenhx9211.github.io/tags/前端性能/"}]},{"title":"react-native 常用的布局：flexbox","slug":"layout","date":"2017-07-10T06:09:14.000Z","updated":"2019-06-19T11:22:14.639Z","comments":true,"path":"2017/07/10/layout/","link":"","permalink":"https://chenhx9211.github.io/2017/07/10/layout/","excerpt":"基本概念 采用 flex 布局的元素就是 flex 容器：flex container.它里面所有的元素都叫子元素：flex item. container 容器存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis).主轴起始位置 main start,结束位置 main end,交叉轴起始位置 cross start,结束位置 cross end. 3.项目默认沿着主轴排列.","text":"基本概念 采用 flex 布局的元素就是 flex 容器：flex container.它里面所有的元素都叫子元素：flex item. container 容器存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis).主轴起始位置 main start,结束位置 main end,交叉轴起始位置 cross start,结束位置 cross end. 3.项目默认沿着主轴排列. container 上设置的属性有 6 个 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction:主轴的方向123.box&#123; flex-direction:row | row-reverse | column | column-reverse;&#125; flex-wrap:如果一条轴线排不下，如何换行123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 1.nowrap:不换行2.wrap：换行，第一行在上方3.wrap-reverse：换行，第一行在下方 flex-flow：是 flex-direction 和 flex-wrap 的简写justify-content：项目在主轴上的对齐方式123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 align-items：项目在交叉轴上如何对齐123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch：如果项目未设置高度或设为 auto，将占满整个容器的高度(默认值) align-content:定义了多根轴线的对齐方式.如果项目只有一根轴线，该属性不起作用123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; item 上设置的属性有 6 个 order flex-grow flex-shrink flex-basis flex align-self order:定义项目的排列顺序.数值越小，排列越靠前，默认为 0.123.item &#123; order: &lt;integer&gt;;&#125; flex-grow:定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大.注意：如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小.注意：如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）.注意：它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flex：是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选.align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性.默认值为 auto.123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 好啦,到此结束！ 注意事项 任何一个元素都可以使用 flex 布局，行内元素使用 display:inline-flex; webkit 内核的浏览器必须加上-webkit 前缀：display：-webkit-flex; 设置 flex 布局以后，子元素的这三个属性将会失效:float,clear,vertical-align.","categories":[{"name":"frontend","slug":"frontend","permalink":"https://chenhx9211.github.io/categories/frontend/"}],"tags":[{"name":"flex","slug":"flex","permalink":"https://chenhx9211.github.io/tags/flex/"}]},{"title":"继承的多种方式","slug":"多种继承方式","date":"2016-09-15T13:09:11.000Z","updated":"2019-06-19T12:31:46.913Z","comments":true,"path":"2016/09/15/多种继承方式/","link":"","permalink":"https://chenhx9211.github.io/2016/09/15/多种继承方式/","excerpt":"JavaScript 各种继承方式和优缺点。","text":"JavaScript 各种继承方式和优缺点。 原型链继承123456789101112131415function Parent() &#123; this.name = \"kevin\";&#125;Parent.prototype.getName = function() &#123; console.log(this.name);&#125;;function Child() &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()); // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 1234567891011121314151617function Parent() &#123; this.names = [\"kevin\", \"daisy\"];&#125;function Child() &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push(\"yayu\");console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向 Parent 传参 2.借用构造函数(经典继承)1234567891011121314151617function Parent() &#123; this.names = [\"kevin\", \"daisy\"];&#125;function Child() &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push(\"yayu\");console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent(name) &#123; this.name = name;&#125;function Child(name) &#123; Parent.call(this, name);&#125;var child1 = new Child(\"kevin\");console.log(child1.name); // kevinvar child2 = new Child(\"daisy\");console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 3.组合继承原型链继承和经典继承双剑合璧。 123456789101112131415161718192021222324252627282930function Parent(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;Parent.prototype.getName = function() &#123; console.log(this.name);&#125;;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child(\"kevin\", \"18\");child1.colors.push(\"black\");console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]var child2 = new Child(\"daisy\", \"20\");console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [\"red\", \"blue\", \"green\"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 4.原型式继承12345function createObj(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: \"kevin\", friends: [\"daisy\", \"kelly\"]&#125;;var person1 = createObj(person);var person2 = createObj(person);person1.name = \"person1\";console.log(person2.name); // kevinperson1.firends.push(\"taylor\");console.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 5. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj(o) &#123; var clone = object.create(o); clone.sayName = function() &#123; console.log(\"hi\"); &#125;; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6. 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;Parent.prototype.getName = function() &#123; console.log(this.name);&#125;;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child(\"kevin\", \"18\");console.log(child1); 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child(\"kevin\", \"18\"); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 123456789101112131415161718192021222324function Parent(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;Parent.prototype.getName = function() &#123; console.log(this.name);&#125;;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function() &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child(\"kevin\", \"18\");console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候：prototype(Child, Parent); 引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chenhx9211.github.io/categories/javascript/"}],"tags":[]},{"title":"原型和原型链","slug":"原型和原型链","date":"2016-07-02T03:29:07.000Z","updated":"2019-06-19T12:31:08.662Z","comments":true,"path":"2016/07/02/原型和原型链/","link":"","permalink":"https://chenhx9211.github.io/2016/07/02/原型和原型链/","excerpt":"","text":"构造函数创建对象我们先使用构造函数创建一个对象： 1234function Person() &#123;&#125;var person = new Person();person.name = \"Kevin\";console.log(person.name); // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = \"Kevin\";var person1 = new Person();var person2 = new Person();console.log(person1.name); // Kevinconsole.log(person2.name); // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 123function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor ，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 12function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： 12345678function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype); // trueconsole.log(Person.prototype.constructor == Person); // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype); // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 1234567891011function Person() &#123;&#125;Person.prototype.name = \"Kevin\";var person = new Person();person.name = \"Daisy\";console.log(person.name); // Daisydelete person.name;console.log(person.name); // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = \"Kevin\";console.log(obj.name); // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？ null，我们可以打印： 1console.log(Object.prototype.__proto__ === null); // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined 与 null 的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子： 123function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor; __proto__其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chenhx9211.github.io/categories/javascript/"}],"tags":[{"name":"原型","slug":"原型","permalink":"https://chenhx9211.github.io/tags/原型/"}]},{"title":"JavaScript代码的解释和执行","slug":"JavaScript代码的解释和执行","date":"2016-04-20T13:09:11.000Z","updated":"2019-06-19T12:30:11.774Z","comments":true,"path":"2016/04/20/JavaScript代码的解释和执行/","link":"","permalink":"https://chenhx9211.github.io/2016/04/20/JavaScript代码的解释和执行/","excerpt":"当函数执行的时候，执行上下文栈、变量对象、作用域链如何变化。","text":"当函数执行的时候，执行上下文栈、变量对象、作用域链如何变化。 &emsp;&emsp;比较两段代码 1234567891011var foo = function() &#123; console.log(\"foo1\");&#125;;foo(); // foo1var foo = function() &#123; console.log(\"foo2\");&#125;;foo(); // foo2 &emsp;&emsp;下面一段代码： 1234567891011function foo() &#123; console.log(\"foo1\");&#125;foo(); // foo2function foo() &#123; console.log(\"foo2\");&#125;foo(); // foo2 打印的结果却是两个 foo2。 JavaScript 引擎并非一行一行地分析解释和执行代码，而是先把整段代码分析解释完成后再执行。分析代码时，如果有重复函数的定义，前面的定义会被后面的覆盖。上面的代码中，第一段代码函数定义采用匿名方式，第二段代码命名函数 foo 的定义，前者被后者覆盖。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://chenhx9211.github.io/categories/javascript/"}],"tags":[]}]}