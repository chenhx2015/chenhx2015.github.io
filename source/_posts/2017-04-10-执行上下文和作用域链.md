---
title: 执行上下文和作用域链
date: 2017-09-06 21:09:11
tags:
categories: javascript
---

## 执行上下文

&emsp;&emsp;JavaScript 引擎执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。JavaScript 引擎创建执行上下文栈（Execution context stack，ECStack）来管理执行上下文。

<!-- more -->

&emsp;&emsp;JavaScript 引擎 开始要解释执行代码的时候，最先遇到的就是全局代码，初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：
&emsp;&emsp;执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

看一个《JavaScript 权威指南》中的例子：

```js
var scope = "global scope";
function checkscope() {
  var scope = "local scope";
  function f() {
    return scope;
  }
  return f();
}
checkscope();
```

```js
var scope = "global scope";
function checkscope() {
  var scope = "local scope";
  function f() {
    return scope;
  }
  return f;
}
checkscope()();
```

两段代码执行的结果一样，但是两段代码的是执行上下文栈的变化不一样。

第一段代码的执行过程模拟：

```js
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```

第二段代码的执行过程模拟：

```js
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```

## 作用域

&emsp;&emsp;作用域是指程序代码中定义变量的区域，它规定了如何查找变量。 一个变量写在函数中，和写在函数外，它的作用域是不同的，也就是所谓局部变量和全局变量。
&emsp;&emsp;在编程语言的设计中，有两种作用域设计方式：静态作用域与动态作用域。JavaScript 采用的是静态作用域。

- 静态作用域，也叫词法作用域(lexical scoping)，函数的作用域在函数定义的时候就决定了。
- 动态作用域，函数的作用域是在函数调用的时候才决定的。

&emsp;&emsp;举看个例子来说明它们直接的之间的区别：

```js
var value = 1;

function foo() {
  console.log(value);
}

function bar() {
  var value = 2;
  foo();
}

bar();

// 结果是 ???
```

&emsp;&emsp;假设 JavaScript 采用静态作用域， foo 函数的执行，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据定义的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。

&emsp;&emsp;假设 JavaScript 采用动态作用域，foo 函数的执行，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用 foo()的位置所在的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。

&emsp;&emsp;JavaScript 采用的是静态作用域，这个例子的结果是 1。

## 作用域链

每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)，包含了全部的局部变量
- 作用域链(Scope chain)
- this

&emsp;&emsp;JavaScript 代码执行时，先从当前上下文中查找变量，如果没有找到，就从父级(词法层面上的父级)执行上下文的变量对象 VO 中查找，一直找到全局上下文的变量对象，也就是全局对象。这样，多个执行上下文的变量对象就构成一个链表，叫做作用域链。
&emsp;&emsp;和作用域一样，JavaScript 函数的作用域链是在函数定义的时候创建的。当函数创建的时候，有一个内部属性 [[scope]]，会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链。举个例子：

```js

function foo() {
    function bar() {
        ...
    }
}

```

函数创建时，各自的[[scope]]为：

```js

foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];

```

&emsp;&emsp;但是[[scope]] 并不代表完整的作用域链。当函数执行时，创建活动对象 AO；再将活动对象 AO 添加到作用链的前端。这时候执行上下文的作用域链，才是完整的，我们命名为 Scope：

```js
Scope = [AO].concat([[Scope]]);
```

结合 ECStack，再来看看上面的列出的《JavaScript 权威指南》中例子的第一段代码：

```js
var scope = "global scope";
function checkscope() {
  var scope = "local scope";
  function f() {
    return scope;
  }
  return f();
}
checkscope();
```

执行过程如下：

1. 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈

```js
ECStack = [globalContext];
```

全局上下文初始化

```js
globalContext = {
  VO: [global, scope, checkscope],
  Scope: [globalContext.VO],
  this: globalContext.VO
};
```

2. checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]

```js
    checkscope.[[scope]] = [
      globalContext.VO
    ];
```

3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

```js
ECStack = [checkscopeContext, globalContext];
```

4. 初始化 checkscope 函数执行上下文：

- 复制函数 [[scope]] 属性创建作用域链，

  ```js
  checkscopeContext = {
      Scope: checkscope.[[scope]],
  }
  ```

- 用 arguments 创建活动对象

- 初始化活动对象，加入形参、函数声明、变量声明

  ```js
  checkscopeContext = {
    AO: {
      arguments: {
        length: 0
      },
      scope: undefined
    }
  };
  ```

- 将活动对象压入 checkscope 作用域链顶端。

  ```js
  checkscopeContext = {
    AO: {
      arguments: {
        length: 0
      },
      scope: undefined
    },
    Scope: [AO, [[Scope]]]
  };
  ```

  同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]

  ```js
      checkscopeContext = {
          AO: {
              arguments: {
                  length: 0
              },
              scope: undefined,
              f: reference to function f(){}
          },
          Scope: [AO, globalContext.VO],
          this: undefined
      }
  ```

5. 开始执行函数，随着函数的执行，修改 AO 的属性值，AO 中的 scope 被赋值"local scope"

```js
checkscopeContext = {
  AO: {
    arguments: {
      length: 0
    },
    scope: "local scope"
  },
  Scope: [AO, [[Scope]]]
};
```

执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈

```js
ECStack = [fContext, checkscopeContext, globalContext];
```

6.f 函数执行上下文初始化, 以下跟第 4 步相同：

- 复制函数 [[scope]] 属性创建作用域链
- 用 arguments 创建活动对象
- 初始化活动对象，即加入形参、函数声明、变量声明
- 将活动对象压入 f 作用域链顶端

```js
fContext = {
  AO: {
    arguments: {
      length: 0
    }
  },
  Scope: [AO, checkscopeContext.AO, globalContext.VO],
  this: undefined
};
```

7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值

8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

```js
ECStack = [checkscopeContext, globalContext];
```

9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出

```js
ECStack = [globalContext];
```

同样可分析第二段代码：

```js
var scope = "global scope";
function checkscope() {
  var scope = "local scope";
  function f() {
    return scope;
  }
  return f;
}
checkscope()();
```
