---
title: 高性能Web建设指南摘要
date: 2017-09-06 21:09:11
tags: 前端性能
categories: frontend
---

&emsp;&emsp;性能黄金法则：10 ～ 20%的总响应时间在下载 html 文档，80 ～ 90%的时间在下载页面中的组件(图片，外部样式表、脚本等)。优化的要点是减少占比达 80 ～ 90%页面组件响应时间。

<!-- more -->

## 规则 1--减少 HTTP 请求

运用以下技术减少 http 请求

- 图片地图
- CSS Sprites
- 内联图片
- 合并样式表
- 合并脚本

## 规则 2--使用内容分发网络

&emsp;&emsp;内容分布网络(CDN)是一组分布在多个不同地理位置的 Web 服务器。静态内容组件发布到 CDN 后，会在多个 Web 服务器都有拷贝，当用户请求内容组件时，CDN 可选择响应时间最短的 Web 服务器(比如离用户最近的服务器)来完成请求。

&emsp;&emsp;CDN 不但带来更短的响应时间，而且可以缓解自身服务器的压力。

## 规则 3--添加 EXpires 头

&emsp;&emsp;http 数据包分为头(head)和身体(body)两部分，头部可添加 Expires 和 Cache-Control 来影响浏览器的缓存时间。有两种方法可以设置 http 头

- 服务器端在响应请求时设置请求的 http 头。
- html 页面通过 meta 标签的 http-equiv 来设定。

```
＜meta http-equiv="expires" content="Wed, 20 Jun 2007 22:33:00 GMT"＞
＜meta http-equiv="Cache-Control" content="max-age=7200"＞
```

&emsp;&emsp;http-equiv 相当于 http 的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容。http-equiv 对应的属性值为 content，可设置各个参数的变量值。
&emsp;&emsp;客户端(比如 JavaScript 脚本)可以在 HTTP 请求中使用的标准 Cache-Control 指令

- Cache-Control: max-age=&lt;seconds&gt;
- Cache-Control: max-stale[=&lt;seconds&gt;
- Cache-Control: min-fresh=&lt;seconds&gt;
- Cache-control: no-cache
- Cache-control: no-store
- Cache-control: no-transform
- Cache-control: only-if-cached

&emsp;&emsp;服务器可以在响应中使用的标准 Cache-Control 指令

- Cache-control: must-revalidate
- Cache-control: no-cache
- Cache-control: no-store
- Cache-control: no-transform
- Cache-control: public
- Cache-control: private
- Cache-control: proxy-revalidate
- Cache-Control: max-age=&lt;seconds&gt;
- Cache-control: s-maxage=&lt;seconds&gt;

## 规则 4--压缩组件

Web 客户端可在 http 请求的头部中加入 Accept-Encoding 来标识客户端支持的压缩方法类型（浏览器一般会自动在每次的请求中加入这个头部指令），Web 服务器会用客户端列出来的方法之一来压缩响应结果，并在响应中加入 Content-Encoding:xxx. 最常用的压缩方法是 gzip。

- 存在代理和 CDN 的情况会变复杂，解决办法是在服务器的响应头部中加入 Vary: Accept-Encoding

## 规则 5--将样式表放在文档顶部

&emsp;&emsp;浏览器一般会逐步呈现已下载的内容，样式表放在文档底部时，为避免当样式变化时重绘页面中的元素，浏览器会延迟显示任何可视化组件。样式表的放置在底部不会影响下载时间，但是会影响内容的逐步呈现，用户会有更慢的感觉，同时它还和白屏、无样式内容的闪烁相关。

## 规则 6--将脚本放在文档底部

&emsp;&emsp;http 1.1 协议建议浏览器从每个主机名下并行的下载两个组件。 然而，下载脚本时实际上会禁用并行下载-即使使用了不同的主机名。其中的原因是：

- 脚本可能使用 document.write 来修改页面内容，因此浏览器会等待，以确保页面能够恰当的布局。
- 保证脚本能按正确的顺序执行，如果并行下载多个脚本，页面次序中在后的脚本有可能先下载完成并执行。

&emsp;&emsp;将脚本放在顶部，会阻塞对其后面内容的呈现，同时阻塞对后面组件的下载。

## 规则 7--避免 CSS 表达式

&emsp;&emsp;CSS expression 方法可接受一个 JavaScript 表达式，很多情况下会导致对其频繁求值，影响浏览器性能。
建议使用一次性表达式，或使用 JavaScript 在事件处理中提供动态行为。

## 规则 8--使用外部 JavaScript 和 CSS

&emsp;&emsp;浏览器可以缓存外部 JavaScript 和 CSS，外部的 JavaScript 和 CSS 还可给网站中其他页面共享。

- 加载后下载
  同样的样式表或脚本同时写入到外部文件和内联到页面中，在页面的 onload 事件再次下载含有同样内容的外部文件。内联的样式和脚本让页面呈现更快，同时网站的其他页面可使用已下载的外部样式和脚本文件。需要注意脚本和 CSS 加载两次可能带来的问题。

## 规则 9--减少 DNS 查找

&emsp;&emsp;浏览器会解析 html 页面外部组件所使用主机名称，http 1.1 协议建议每个主机名称两个并行下载；因而在 html 页面中对页面中的组件使用多个主机名称，可提高并行下载数量。然而过多的主机名称，可能不能更好的利用 http 1.1 协议的 keep-alive 特性，同时导致浏览器进行多次 DNS 查找。综合两个考虑，建议在页面中使用至少两个，但不要超过 4 个主机名。

## 规则 10--精简（minify） JavaScript 、 CSS

压缩混淆 JavaScript 代码，以减小代码尺寸。同样对 CSS，html 都可使用工具进行 minify。

## 规则 11--避免重定向

一些容易忽视的场景：

- url 指向目录时，结尾不要省略斜线/，不要让 Web 服务器为你发出重定向
- 内部流量跟踪，使用 referer 日志跟踪流量取向，而不是使用重定向。
- 出战流量跟踪，不实用重定向，而使用信标 beancon--一个在 url 中包含有跟踪信息的 http 请求（信标响应通常是一个 1px X 1px 的透明图片；或者使用 204 响应，因为它更小，从来不会被缓存，而且绝对不会改变浏览器状态。），跟踪信息可以从信标的 web 服务器请求日志中提取出来。

&emsp;&emsp;使用图片的信标例子

```
<a href="http://en.wikipedia.org/wiki/Performance"
   onclick="resultBeacon(this); return false;">Performance - Wikipedia</a>

<script>
var beacon;
function resultBeacon(anchor) {
    beacon = new Image();
    beacon.onload = gotoUrl;
    beacon.onerror = gotoUrl;  // in case the image fails, we still want to redirect the user
	  beacon.anchor = anchor;
    beacon.src = "/bin/beacon204.gif?url=" + escape(anchor.href);
}

function gotoUrl() {
    document.location = beacon.anchor.href;
}
</script>
```

&emsp;&emsp;使用 XHttpRequest 的信标例子

```
<a href="http://en.wikipedia.org/wiki/Performance"
   onclick="resultBeacon(this); return false;">Performance - Wikipedia</a>

<script>
var gAnchor, gXhrObj;

function resultBeacon(anchor) {
	gAnchor = anchor;
  beacon_src = "http://stevesouders.com/images/beacon.gif?url=" + escape(anchor.href) + "&t=" + Number(new Date());

	gXhrObj = getXHRObject();
	gXhrObj.onreadystatechange = xhrCallback;
	try {
		gXhrObj.open("GET", beacon_src, true);  // true == async
		gXhrObj.send("");
	}catch(err) {
		gotoUrl();  // on failure, just go to the target url
  }
}

function xhrCallback(respAr) {
    var readyState = ( respAr && "undefined" != typeof(respAr.readyState) ? respAr.readyState : gXhrObj.readyState );
    if ( 2 == readyState ) {    // the request is done enough to risk unloading the page
        gotoUrl();
    }
}

function gotoUrl() {
    document.location = gAnchor.href;
}

// Find the right syntax for creating an XHR object.
function getXHRObject() {
    var xhrObj = false;
    try {
        xhrObj = new XMLHttpRequest();
    }catch(e){
        var progid = ['MSXML2.XMLHTTP.5.0', 'MSXML2.XMLHTTP.4.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP', 'Microsoft.XMLHTTP'];
        for ( var i=0; i < progid.length; ++i ) {
            try {
                xhrObj = new ActiveXObject(progid[i]);
            }catch(e) {
            }
        }
    }
    finally {
        return xhrObj;
    }
}

</script>

```

## 规则 12--移除重复脚本

&emsp;&emsp;团队规模和脚本数量变大，往往会有相同的脚本代码。需要实现一个脚本管理模块，避免重复的脚本。

## 规则 13--配置或移除 ETag

&emsp;&emsp;ETag，Entity Tag-实体标签是 Web 服务器和浏览器用于确认缓存组件有效性的一种机制。条件 Get 请求会比较文件修改日期和 ETag 标签，ETag 标签对于静态文件而言不利。因此建议是在服务器端配置 ETag 或者干脆移除它。

## 规则 14--使 AJAX 可缓存

&emsp;&emsp;某些 AJAX Get 请求可以被缓存，而不影响用户体验。要使这些 AJAX 请求被缓存，需要

- 给响应设置 HTTP Cache-Control 或 Expires 头
- 请求的 URL 中应包括响应的个性化和动态化数据，这样缓存结果才正确的反映出个性化和动态化。
