<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHX的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chenhx9211.github.io/"/>
  <updated>2019-06-25T03:01:28.102Z</updated>
  <id>https://chenhx9211.github.io/</id>
  
  <author>
    <name>chenhuaxiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react-use-locked-state</title>
    <link href="https://chenhx9211.github.io/2019/06/20/2019-06-20-react-use-locked-state/"/>
    <id>https://chenhx9211.github.io/2019/06/20/2019-06-20-react-use-locked-state/</id>
    <published>2019-06-20T14:13:21.000Z</published>
    <updated>2019-06-25T03:01:28.102Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;React 中的数据流是单向的，并顺着组件层级从上往下传递。这在绝大多数的场合下，都很好使，稍微注意一下避免无谓的的重新渲染即可。配合上 redux，那更是把数据和应用状态管理得井井有条，给人以深刻的印象。</p><p>&emsp;&emsp;最近遇到一个需求，用户在访问页面后，前端使用异步请求获取后端给予的多个勋章奖励，对于每个勋章，需弹出对话框，等用户确认后，再在页面其它组件上显示动画；多个勋章，挨个依以上次序处理。对话框和动画显示组件并没有上下级组件关系，只是个平行关系。</p><a id="more"></a><p>&emsp;&emsp;一开始只使用 react（因为整个 app 挺简单的，就没使用 redux），在异步请求，对话框关闭回调中，以及相关个组件中加入控制逻辑，做下来一看，代码加了不少，而且这个控制逻辑分散在多个组件中，代码的味道很差，需要考虑下重构了。</p><p>&emsp;&emsp;首先考虑了使用 redux 来控制这个显示的次序，估算一下，得为相关组件单独设计出好几个 state 和 action，同样的，组件中的其余代码会和这个控制逻辑没什么关系。这种场景，redux 也不太好应付啊。</p><p>&emsp;&emsp;最终使用的是 react 新引入的 hook，使用起来非常方便，简单的项目不再需要一个 redux 之类的状态管理器来保存应用状态。不过针对动画显示次序这样的需求，hook 也不好直接匹配。在自定义了一个 hook 之后，程序才算是比较简洁了，而且 App 重新渲染的次数也少了。<br><a href="https://github.com/chenhx2015/react-use-locked-state" target="_blank" rel="noopener">项目代码</a><br><a href="https://chenhx2015.github.io/react-use-locked-state/" target="_blank" rel="noopener">演示</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"taotao"</span>, <span class="number">2</span>, <span class="string">"child"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"taotao"</span>, <span class="number">2</span>, <span class="string">"child"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"taotao"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">2</span>;</span><br><span class="line">Person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，如果查属性和方法，会先找自己的，找不到再去原型上面找</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;React 中的数据流是单向的，并顺着组件层级从上往下传递。这在绝大多数的场合下，都很好使，稍微注意一下避免无谓的的重新渲染即可。配合上 redux，那更是把数据和应用状态管理得井井有条，给人以深刻的印象。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最近遇到一个需求，用户在访问页面后，前端使用异步请求获取后端给予的多个勋章奖励，对于每个勋章，需弹出对话框，等用户确认后，再在页面其它组件上显示动画；多个勋章，挨个依以上次序处理。对话框和动画显示组件并没有上下级组件关系，只是个平行关系。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://chenhx9211.github.io/categories/code/"/>
    
    
      <category term="react" scheme="https://chenhx9211.github.io/tags/react/"/>
    
      <category term="hook" scheme="https://chenhx9211.github.io/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>基于vue vuex es6 webpack的项目</title>
    <link href="https://chenhx9211.github.io/2019/06/18/%E5%9F%BA%E4%BA%8Evue%20vuex%20es6%20webpack%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>https://chenhx9211.github.io/2019/06/18/基于vue vuex es6 webpack的项目/</id>
    <published>2019-06-18T05:46:40.396Z</published>
    <updated>2019-06-20T13:18:22.507Z</updated>
    
    <content type="html"><![CDATA[<p>一个基于 vue+vuex+es6+webpack 技术栈的 spa 开店项目</p><a id="more"></a><ol><li>使用了 vue-router 来做页面的路由跳转，主页跳转至详情页面使用具体路由的配置。</li><li>整个项目使用的是 es6 的语法<br>我比较喜欢 es6 的语法，arrow function，let,const,template string，解构,尤其是在 react 里面比较喜欢用的 class,extends,super。</li><li>状态管理用 vuex</li><li>使用 axios 从后端获取数据</li><li>对啦，项目使用的脚手架 vue-cli,快速上手</li><li>github 地址：<a href="https://github.com/chenhx9211/vue-onlineStore" target="_blank" rel="noopener">https://github.com/chenhx9211/vue-onlineStore</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个基于 vue+vuex+es6+webpack 技术栈的 spa 开店项目&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="https://chenhx9211.github.io/categories/code/"/>
    
    
      <category term="vue" scheme="https://chenhx9211.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="https://chenhx9211.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>react hooks 学习体会</title>
    <link href="https://chenhx9211.github.io/2019/04/03/react-hook/"/>
    <id>https://chenhx9211.github.io/2019/04/03/react-hook/</id>
    <published>2019-04-03T14:13:21.000Z</published>
    <updated>2019-06-20T06:26:33.255Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;某天一看 react 官方文档，发现多了一个很 🐂 的新特性，hooks，那么为什么会出现 hooks 呢？<br>&emsp;&emsp;相信很多人都有这个体验，有些时候搞不清楚到底用哪个生命周期函数，并且使用生命周期函数的同时还要写很多相同的代码在 shouldUpdate 里面，做很多重复的工作，代码冗余。<br>&emsp;&emsp;组件中的 this 指向问题，很容易忘记绑定 this，回头来加，很麻烦<br>&emsp;&emsp;到底是用有状态组件呢？还是用无状态组件呢？</p><p>&emsp;&emsp;随着函数式编程兴起，我们建议尽量用函数式编程的思维来开发我们的组件，加上不用 class 方式写组件了，hooks 也就粉墨登场了！</p><a id="more"></a><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>&emsp;&emsp;下面先看一个简单的 Hooks!</p><p>&emsp;&emsp;这是一个有状态的组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123;</span></span><br><span class="line"><span class="regexp">              count: this.state.count + 1</span></span><br><span class="line"><span class="regexp">            &#125;);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          Click Me!</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>来看看我们使用了 hooks 之后的版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p&gt;You clicked &#123; count &#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click Me!&lt;/</span>button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一看简单多了！可以看到， Example 变成了一个函数，但这个函数却有自己的状态（count），同时它还可以更新自己的状态（setCount）。这个函数之所以这么了不得，就是因为它注入了一个 hook– useState，就是这个 hook 让我们的函数变成了一个有状态的函数。</p><p>先来理解一下上面的 hooks 改版之后发生了什么呢？</p><h3 id="申明了一个状态变量"><a href="#申明了一个状态变量" class="headerlink" title="申明了一个状态变量"></a>申明了一个状态变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;useState 是 react 自带的一个 hook 函数，它的作用就是用来声明状态变量。 useState 这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第 [0]项是当前当前的状态值，第 [1]项是可以改变状态值的方法函数。</p><p>所以我们做的事情其实就是，声明了一个状态变量 count，把它的初始值设为 0，同时提供了一个可以更改 count 的函数 setCount。<br>上面这种表达形式，是借用了 es6 的数组解构（array destructuring），它可以让我们的代码看起来更简洁.</p><p>如果不用数组解构的话，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _useState = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> count = _useState[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> setCount = _useState[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。我们就按照官方推荐使用数组解构就好</p><h3 id="读取状态值"><a href="#读取状态值" class="headerlink" title="读取状态值"></a>读取状态值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;就不用写成之前的 {this.state.count}, 看起来简洁好多！</p><h3 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了 useState 这个 hook 外，还有很多别的 hook，比如 useEffect 提供了类似于 componentDidMount 等生命周期钩子的功能， useContext 提供了上下文（context）的功能等等。</p><p>&emsp;&emsp;useEffect 期待中。。。</p><p>&emsp;&emsp;Hooks 本质上就是一类特殊的函数，它们可以为你的函数型组件（function component）注入一些特殊的功能。咦？这听起来有点像被诟病的 Mixins 啊？难道是 Mixins 要在 react 中死灰复燃了吗？当然不会了，等会我们再来谈两者的区别。总而言之，这些 hooks 的目标就是让你不再写 class，让 function 一统江湖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;某天一看 react 官方文档，发现多了一个很 🐂 的新特性，hooks，那么为什么会出现 hooks 呢？&lt;br&gt;&amp;emsp;&amp;emsp;相信很多人都有这个体验，有些时候搞不清楚到底用哪个生命周期函数，并且使用生命周期函数的同时还要写很多相同的代码在 shouldUpdate 里面，做很多重复的工作，代码冗余。&lt;br&gt;&amp;emsp;&amp;emsp;组件中的 this 指向问题，很容易忘记绑定 this，回头来加，很麻烦&lt;br&gt;&amp;emsp;&amp;emsp;到底是用有状态组件呢？还是用无状态组件呢？&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;随着函数式编程兴起，我们建议尽量用函数式编程的思维来开发我们的组件，加上不用 class 方式写组件了，hooks 也就粉墨登场了！&lt;/p&gt;
    
    </summary>
    
      <category term="framework" scheme="https://chenhx9211.github.io/categories/framework/"/>
    
    
      <category term="react" scheme="https://chenhx9211.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>create-react-app .env 使用</title>
    <link href="https://chenhx9211.github.io/2018/11/12/create-react-app/"/>
    <id>https://chenhx9211.github.io/2018/11/12/create-react-app/</id>
    <published>2018-11-12T02:13:26.000Z</published>
    <updated>2019-06-28T02:08:44.094Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;create-react-app 是 React 官方支持的创建单页 React 应用的工具。虽然它也通过 Webpack 来打包，但是用不着去做 Webpack 繁琐的配置，上手非常快，而且前端开发需要的优化和处理，基本上都覆盖到了。<br>&emsp;&emsp;化繁为简，的确是把利器，目前为止，还没遇到过需要重新做 Webpack 包配置的情况。有一个缺点，用久了这个，很容易忘记如何使用 Webpack。<br>&emsp;&emsp;create-react-app 还提供了环境变量机制，增加加几个简单的文件就可以设置开发、测试和产品环境下的环境变量。</p><a id="more"></a><p>&emsp;&emsp;像 App 部署时的 url，后端 api 请求的 url 等等，在开发、测试和产品环境下，一般都是不同的。不使用环境变量机制，应用程序代码就得自己处理这些差异，要能识别不同的环境，在不同的环境下使用其对应的 url，基本上是把这些这些差异硬编码到应用代码中。<br>&emsp;&emsp;再看下使用环境变量机制的做法，如果项目的根目录下存在以下文件，app 就可以使用这些文件中设置的环境变量。</p><ul><li>.env: 默认</li><li>.env.local: 除了测试环境，其他所有环境都会加载这个文件.</li><li>.env.development, .env.test, .env.production: 指定开发、测试和产品环境下的变量.</li><li>.env.development.local, .env.test.local, .env.production.local: 覆盖环境变量指定的设置.</li></ul><p>&emsp;&emsp;各个环境下，分别加载以下文件：</p><ul><li><code>npm start: .env.development.local, .env.development, .env.local, .env</code></li><li><code>npm run build: .env.production.local, .env.production, .env.local, .env</code></li><li><code>npm test: .env.test.local, .env.test, .env (注意，不加载 .env.local)</code></li></ul><p>&emsp;&emsp;左边的文件比右边的优先级高，也就是说多个文件中如果有相同的环境变量，优先使用左边文件定义的环境变量。</p><p>&emsp;&emsp;举个例子，开发中，app 对应的 url 都是‘/’，而测试、部署的代码对应的可能不会是‘/’。只需要在对应的环境变量文件设置 PUBLIC_URL 为各自对应的 url，应用代码中就可以使用 process.env.PUBLIC_URL。<br>&emsp;&emsp;注意：PUBLIC_URL 是 create-react-app 定义，除了 NODE_ENV, 自定义环境变量起名都要 REACT_APP*为起首字符。其它 create-react-app 定义的环境变量还有：BROWSER，HOST，PORT，HTTPS 等。</p><p>&emsp;&emsp;环境变量机制 是通过 dotenv 和 webpack 的配置来实现的，create-react-app 帮我们都配置好了，直接使用就行。顺便提一下，浏览器环境下是没有 process.env 对象的，webpack 在打包时，针对浏览器环境会使用一个插件创建出这个对象，因此在应用程序代码在浏览器环境下一样可以使用 process.env 下的环境变量。</p><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><ul><li><a href="https://facebook.github.io/create-react-app/docs/getting-started" target="_blank" rel="noopener">create-react-app 文档</a></li><li><a href="https://facebook.github.io/create-react-app/docs/adding-custom-environment-variables" target="_blank" rel="noopener">自定义环境变量</a></li><li><a href="https://facebook.github.io/create-react-app/docs/advanced-configuration" target="_blank" rel="noopener">高级配置</a></li><li><a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotenv</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;create-react-app 是 React 官方支持的创建单页 React 应用的工具。虽然它也通过 Webpack 来打包，但是用不着去做 Webpack 繁琐的配置，上手非常快，而且前端开发需要的优化和处理，基本上都覆盖到了。&lt;br&gt;&amp;emsp;&amp;emsp;化繁为简，的确是把利器，目前为止，还没遇到过需要重新做 Webpack 包配置的情况。有一个缺点，用久了这个，很容易忘记如何使用 Webpack。&lt;br&gt;&amp;emsp;&amp;emsp;create-react-app 还提供了环境变量机制，增加加几个简单的文件就可以设置开发、测试和产品环境下的环境变量。&lt;/p&gt;
    
    </summary>
    
      <category term="framework" scheme="https://chenhx9211.github.io/categories/framework/"/>
    
    
      <category term="react" scheme="https://chenhx9211.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>仿淘宝商城App</title>
    <link href="https://chenhx9211.github.io/2018/11/03/react-mall/"/>
    <id>https://chenhx9211.github.io/2018/11/03/react-mall/</id>
    <published>2018-11-03T02:13:26.000Z</published>
    <updated>2019-06-20T10:18:39.218Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近利用业余时间学习了 React，对它的函数组件的写法很感兴趣，那么测试不就方便多了么，听上去真的是福音。是否真有那么好，写了才知道。<br>&emsp;&emsp;目标是写个仿淘宝商城的简单 Demo，打算用 react/redux 全家桶来实现。<br>&emsp;&emsp;社区里有不少优秀的脚手架，直接使用能省不少事，但既然以学习摸索为主，就不打算使用它们，除了用 create-app—cli，从零开始，先后加入了 react-router，react-redux，redux-logger，redux-thunk，redux-persist 等第三方代码包。项目代码放在<a href="https://github.com/chenhx2015/taobao-react" target="_blank" rel="noopener">仿仿淘宝商城 Demo 代码</a>，<a href="https://chenhx2015.github.io/taobao-react" target="_blank" rel="noopener">在线 Demo</a></p><p><img src="/images/taobao-react-index.png" alt="首页"> <img src="/images/taobao-react-account.png" alt="账户"></p><p>&emsp;&emsp;小结：</p><ul><li>要把整个应用的数据、状态都存到 Redux 中去；</li><li>努力克服把业务逻辑就近放到 React 组件的冲动，把它放到 reducer 函数去；测试业务逻辑是否正确，也只需要测试 reduer 函数了，这个单元测试就简单多了；</li><li>用一堆无状态的组件拼出个整个应用；函数组件的写法对把业务逻辑和界面逻辑分离很有帮助。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近利用业余时间学习了 React，对它的函数组件的写法很感兴趣，那么测试不就方便多了么，听上去真的是福音。是否真有那么好，写了才知道。&lt;br&gt;&amp;emsp;&amp;emsp;目标是写个仿淘宝商城的简单 Demo，打算用 react/redux 全家桶来实现
      
    
    </summary>
    
      <category term="code" scheme="https://chenhx9211.github.io/categories/code/"/>
    
    
      <category term="redux" scheme="https://chenhx9211.github.io/tags/redux/"/>
    
      <category term="react" scheme="https://chenhx9211.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>redux学习心得</title>
    <link href="https://chenhx9211.github.io/2018/04/13/redux/"/>
    <id>https://chenhx9211.github.io/2018/04/13/redux/</id>
    <published>2018-04-13T02:13:26.000Z</published>
    <updated>2019-06-20T06:26:17.355Z</updated>
    
    <content type="html"><![CDATA[<p>我学习 redux 的心得：</p><p>1.单一的状态树，单向数据流</p><p>2.整个项目只有一个 store</p><a id="more"></a><p>3.由用户发出一个 action，reducer 方法接收这个方法和一个老的 state，再重新返回一个新 state,视图再更新</p><p>4.在开发的时候一般会把很多个 reducer 用 redux 里面的 combineReducers 方法合并在一个，便于管理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我学习 redux 的心得：&lt;/p&gt;
&lt;p&gt;1.单一的状态树，单向数据流&lt;/p&gt;
&lt;p&gt;2.整个项目只有一个 store&lt;/p&gt;
    
    </summary>
    
      <category term="framework" scheme="https://chenhx9211.github.io/categories/framework/"/>
    
    
      <category term="redux" scheme="https://chenhx9211.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>es6</title>
    <link href="https://chenhx9211.github.io/2018/04/12/es6/"/>
    <id>https://chenhx9211.github.io/2018/04/12/es6/</id>
    <published>2018-04-12T10:54:22.000Z</published>
    <updated>2019-06-19T09:17:10.534Z</updated>
    
    <content type="html"><![CDATA[<p>先说一下 let 吧！</p><ol><li>let 和 var 一样用来声明变量，但是不同的是：let 命令只在所在的代码块内有效(es5 没有块级作用域)</li><li>for 循环里面不要再用 var 了，要不然每次输出来的都是最后一个遍历出来的值</li><li>let 不存在变量提升，一定要先声明后使用，要不然报错；而 var 可以先使用再声明，输出来 undefined</li><li>暂时性死区，只要进去作用域，所要使用的变量就已经存在了，但是不可以获取，只有等到变量声明了才可以获取和使用它</li><li>let 不允许在同一作用域内重复声明</li></ol><a id="more"></a><p>为什么需要块级作用域呢？<br>@内层变量可能会覆盖外层变量<br>@用来计数的循环变量泄露为全局变量，很容易造成内存泄漏</p><p>下面再说说 const!</p><ol><li>用来声明常量，所以一旦声明变量，就必须立即初始化，不能留到以后赋值，只声明不赋值，就会报错</li><li>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效</li><li>const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用</li><li>const 声明的常量，也与 let 一样不可重复声明</li></ol><h4 id="结构先不说，比较简单，主要分为数组，对象，字符串，数值，布尔值，函数参数解构"><a href="#结构先不说，比较简单，主要分为数组，对象，字符串，数值，布尔值，函数参数解构" class="headerlink" title="结构先不说，比较简单，主要分为数组，对象，字符串，数值，布尔值，函数参数解构"></a>结构先不说，比较简单，主要分为数组，对象，字符串，数值，布尔值，函数参数解构</h4><p>看了一圈下来，关键是用途，总结一下：</p><ol><li>交换变量的值</li><li>从函数返回多个值</li><li>函数参数的定义</li><li>提取 json 数据(我认为这个比较实用，拿出来可以直接放到视图)</li><li>遍历 Map 结构</li></ol><h4 id="字符串的扩展-下面几个是我认为能用到项目里面频率相对高的"><a href="#字符串的扩展-下面几个是我认为能用到项目里面频率相对高的" class="headerlink" title="字符串的扩展(下面几个是我认为能用到项目里面频率相对高的)"></a>字符串的扩展(下面几个是我认为能用到项目里面频率相对高的)</h4><ol><li>Unicode 表示法：eg:\u{1F680}</li><li>遍历接口器，可以把字符串的每一个字符都遍历出来</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> codePoint of <span class="string">'foo'</span>) &#123;</span><br><span class="line">    console.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line">// <span class="string">"f"</span></span><br><span class="line">// <span class="string">"o"</span></span><br><span class="line">// <span class="string">"o"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>at(),这个和 es5 的 charAt()差不多，并且能识别出来码点大于 0xFFFF 的字符</li><li>includes(),startsWith(),endsWith(),he es5 的 indexOf 方法差不多，它返回的是布尔值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) // <span class="literal">true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) // <span class="literal">true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="5"><li>repeat()<br>直接看下面的代码吧</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(3) // <span class="string">"xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(2) // <span class="string">"hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(0) // <span class="string">""</span></span><br></pre></td></tr></table></figure><p>注意：如果是小数，则取整；负数或者 Infinity，报错；0 到-1 的都视为 0；NaN 视为 0</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先说一下 let 吧！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;let 和 var 一样用来声明变量，但是不同的是：let 命令只在所在的代码块内有效(es5 没有块级作用域)&lt;/li&gt;
&lt;li&gt;for 循环里面不要再用 var 了，要不然每次输出来的都是最后一个遍历出来的值&lt;/li&gt;
&lt;li&gt;let 不存在变量提升，一定要先声明后使用，要不然报错；而 var 可以先使用再声明，输出来 undefined&lt;/li&gt;
&lt;li&gt;暂时性死区，只要进去作用域，所要使用的变量就已经存在了，但是不可以获取，只有等到变量声明了才可以获取和使用它&lt;/li&gt;
&lt;li&gt;let 不允许在同一作用域内重复声明&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://chenhx9211.github.io/categories/javascript/"/>
    
    
      <category term="es6" scheme="https://chenhx9211.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Web站点加速最佳实践</title>
    <link href="https://chenhx9211.github.io/2017/11/08/Best%20Practices%20for%20Speeding%20Up%20Your%20Web%20Site/"/>
    <id>https://chenhx9211.github.io/2017/11/08/Best Practices for Speeding Up Your Web Site/</id>
    <published>2017-11-08T03:29:07.000Z</published>
    <updated>2019-06-19T09:11:19.277Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在<a href="/2017/09/06/高性能Web建设指南摘要">高性能 Web 建设指南摘要</a>总结了前端性能优化的 14 条原则，在高性能 Web 进阶指南中，也由一些建议。几年过去了，Yahoo 的 Exceptional Performance team 总结的规则也发展到 35 条。<a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">原文地址</a>。规则分为七类：页面内容，服务器，cookie，css，javascript，图片和手机端。<br>&emsp;&emsp; 根据原文翻译整理了一下，记录了一些新的原则。感谢前端工具的发展，如 webpack，eslint，其中很多优化原则都可以让工具自动实施。其中原来的黄金规则可参看<a href="/2017/09/06/高性能Web建设指南摘要">高性能 Web 建设指南摘要</a></p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="减少-DOM-元素数量"><a href="#减少-DOM-元素数量" class="headerlink" title="减少 DOM 元素数量"></a>减少 DOM 元素数量</h3><p>&emsp;&emsp; 检查文档 dom 数量的简单办法，在浏览器控制台运行下一行代码:<br>document.getElementsByTagName(‘*‘).length</p><h3 id="尽量减少使用-iframe"><a href="#尽量减少使用-iframe" class="headerlink" title="尽量减少使用 iframe"></a>尽量减少使用 iframe</h3><p>iframe 帮助第三方内容嵌入，帮助脚本并行下载，但是使用它的代价很大，它会阻塞页面加载</p><h3 id="不使用-404"><a href="#不使用-404" class="headerlink" title="不使用 404"></a>不使用 404</h3><p>一个无用的响应(例如 404 Not Found) 完全没有用处，只会降低用户体验。有些站点使用诸如”Did you mean X?”的 404 响应, 对用户体验有帮助但是浪费了服务器资源(例如数据库等). 如果链接是一个外部的脚本，而返回的响应是 404，尤其糟糕：首先, 脚本下载会阻塞并行下载，其次如果 404 响应的 body 是 JavaScript 代码，浏览器会去解析脚本。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="Flush-the-Buffer-Early"><a href="#Flush-the-Buffer-Early" class="headerlink" title="Flush the Buffer Early"></a>Flush the Buffer Early</h3><p>When users request a page, it can take anywhere from 200 to 500ms for the backend server to stitch together the HTML page. During this time, the browser is idle as it waits for the data to arrive. In PHP you have the function flush(). It allows you to send your partially ready HTML response to the browser so that the browser can start fetching components while your backend is busy with the rest of the HTML page. The benefit is mainly seen on busy backends or light frontends.</p><p>A good place to consider flushing is right after the HEAD because the HTML for the head is usually easier to produce and it allows you to include any CSS and JavaScript files for the browser to start fetching in parallel while the backend is still processing.</p><p>Example:</p><pre><code>  ... &lt;!-- css, js --&gt;&lt;/head&gt;&lt;?php flush(); ?&gt;&lt;body&gt;  ... &lt;!-- content --&gt;</code></pre><h3 id="Use-GET-for-AJAX-Requests"><a href="#Use-GET-for-AJAX-Requests" class="headerlink" title="Use GET for AJAX Requests"></a>Use GET for AJAX Requests</h3><p>The Yahoo! Mail team found that when using XMLHttpRequest, POST is implemented in the browsers as a two-step process: sending the headers first, then sending data. So it’s best to use GET, which only takes one TCP packet to send (unless you have a lot of cookies). The maximum URL length in IE is 2K, so if you send more than 2K data you might not be able to use GET.</p><p>An interesting side affect is that POST without actually posting any data behaves like GET. Based on the HTTP specs, GET is meant for retrieving information, so it makes sense (semantically) to use GET when you’re only requesting data, as opposed to sending data to be stored server-side.</p><h3 id="避免-Image-元素的-src-属性为空"><a href="#避免-Image-元素的-src-属性为空" class="headerlink" title="避免 Image 元素的 src 属性为空"></a>避免 Image 元素的 src 属性为空</h3><p>无论是 html 代码中的<code>&lt;img src=&quot;&quot;&gt;</code>或是通过 JavaScript</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &quot;&quot;;</span><br></pre></td></tr></table></figure><p>都导致同样结果: 浏览器多发出一个 http 请求：</p><ul><li>Internet Explorer 会请求页面目录</li><li>Safari 和 Chrome 会请求页面.</li><li>Firefox 3 以及之前的版本如同 Safari 和 Chrome, 不过 3.5 不再发出请求.</li><li>Opera 不会发出请求.</li></ul><p>Why is this behavior bad?</p><p>Cripple your servers by sending a large amount of unexpected traffic, especially for pages that get millions of page views per day.<br>Waste server computing cycles generating a page that will never be viewed.<br>Possibly corrupt user data. If you are tracking state in the request, either by cookies or in another way, you have the possibility of destroying data. Even though the image request does not return an image, all of the headers are read and accepted by the browser, including all cookies. While the rest of the response is thrown away, the damage may already be done.</p><p>HTML5 增加了对 to the description of the tag’s src attribute to instruct browsers not to make an additional request</p><p>The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string.<br>Hopefully, browsers will not have this problem in the future. Unfortunately, there is no such clause for <code>&lt;script src=&quot;&quot;&gt;</code> and <code>&lt;link href=&quot;&quot;&gt;</code> Maybe there is still time to make that adjustment to ensure browsers don’t accidentally implement this behavior.<br>This rule was inspired by Yahoo!’s JavaScript guru Nicolas C. Zakas. For more information check out his article “Empty image src can destroy your site”.</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="减少-Cookie-大小"><a href="#减少-Cookie-大小" class="headerlink" title="减少 Cookie 大小"></a>减少 Cookie 大小</h3><h3 id="静态内容使用-Cookie-free-域名"><a href="#静态内容使用-Cookie-free-域名" class="headerlink" title="静态内容使用 Cookie-free 域名"></a>静态内容使用 Cookie-free 域名</h3><p>&emsp;&emsp; 浏览器请求静态图片等内容时候，Web 服务器一般并不使用 Cookie。因此，静态内容的主机名称使用 cookie-free 域名，浏览器就不会发送 cookie，可减少网络流量。</p><h3 id="避免使用-CSS-Filter"><a href="#避免使用-CSS-Filter" class="headerlink" title="避免使用 CSS Filter"></a>避免使用 CSS Filter</h3><p>&emsp;&emsp; The IE-proprietary AlphaImageLoader filter aims to fix a problem with semi-transparent true color PNGs in IE versions &lt; 7. The problem with this filter is that it blocks rendering and freezes the browser while the image is being downloaded. It also increases memory consumption and is applied per element, not per image, so the problem is multiplied.</p><p>&emsp;&emsp; The best approach is to avoid AlphaImageLoader completely and use gracefully degrading PNG8 instead, which are fine in IE. If you absolutely need AlphaImageLoader, use the underscore hack _filter as to not penalize your IE7+ users.</p><h3 id="Choose-over-import"><a href="#Choose-over-import" class="headerlink" title="Choose  over @import"></a>Choose <link> over @import</h3><p>&emsp;&emsp; One of the previous best practices states that CSS should be at the top in order to allow for progressive rendering.</p><p>&emsp;&emsp; In IE @import behaves the same as using <link> at the bottom of the page, so it’s best not to use it.</p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="Minimize-DOM-Access"><a href="#Minimize-DOM-Access" class="headerlink" title="Minimize DOM Access"></a>Minimize DOM Access</h3><p>&emsp;&emsp; Accessing DOM elements with JavaScript is slow so in order to have a more responsive page, you should:</p><p>Cache references to accessed elements<br>Update nodes “offline” and then add them to the tree<br>Avoid fixing layout with JavaScript<br>For more information check the YUI theatre’s “High Performance Ajax Applications” by Julien Lecomte.</p><h3 id="Develop-Smart-Event-Handlers"><a href="#Develop-Smart-Event-Handlers" class="headerlink" title="Develop Smart Event Handlers"></a>Develop Smart Event Handlers</h3><p>&emsp;&emsp; Sometimes pages feel less responsive because of too many event handlers attached to different elements of the DOM tree which are then executed too often. That’s why using event delegation is a good approach. If you have 10 buttons inside a div, attach only one event handler to the div wrapper, instead of one handler for each button. Events bubble up so you’ll be able to catch the event and figure out which button it originated from.</p><p>You also don’t need to wait for the onload event in order to start doing something with the DOM tree. Often all you need is the element you want to access to be available in the tree. You don’t have to wait for all images to be downloaded. DOMContentLoaded is the event you might consider using instead of onload, but until it’s available in all browsers, you can use the YUI Event utility, which has an onAvailable method.</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="Optimize-CSS-Sprites"><a href="#Optimize-CSS-Sprites" class="headerlink" title="Optimize CSS Sprites"></a>Optimize CSS Sprites</h3><p>Arranging the images in the sprite horizontally as opposed to vertically usually results in a smaller file size.<br>Combining similar colors in a sprite helps you keep the color count low, ideally under 256 colors so to fit in a PNG8.<br>“Be mobile-friendly” and don’t leave big gaps between the images in a sprite. This doesn’t affect the file size as much but requires less memory for the user agent to decompress the image into a pixel map. 100x100 image is 10 thousand pixels, where 1000x1000 is 1 million pixels</p><h3 id="不要在-HTML-中缩放图片"><a href="#不要在-HTML-中缩放图片" class="headerlink" title="不要在 HTML 中缩放图片"></a>不要在 HTML 中缩放图片</h3><p>&emsp;&emsp; 例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 图片 mycat.jpg 就应该是 100x100px，而不是一个 500x500px.</p><h3 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="favicon.ico"></a>favicon.ico</h3><p>&emsp;&emsp;浏览器每次访问网站，都会自动请求，因此最好是在根目录创建一个 favicon.ico，同时尽可能缓存</p><ul><li>尽量小于 1K.</li><li>设置 Expires 头</li></ul><h2 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h2><h3 id="组件-译者注：指的是-html-页面，css，js，图片等等页面内容文件-的大小不要超过-25K"><a href="#组件-译者注：指的是-html-页面，css，js，图片等等页面内容文件-的大小不要超过-25K" class="headerlink" title="组件(译者注：指的是 html 页面，css，js，图片等等页面内容文件)的大小不要超过 25K"></a>组件(译者注：指的是 html 页面，css，js，图片等等页面内容文件)的大小不要超过 25K</h3><p>iPhone 不会缓冲大于 25K 的内容。 值得注意的是 25k 是指解压后的文件大小，单独使用 gzip 不起作用，因此减少文件的大小很重要。</p><p>详情可参看 Wayne Shea 和 Tenni Theurer 写的<a href="http://yuiblog.com/blog/2008/02/06/iphone-cacheability/" target="_blank" rel="noopener">“Performance Research, Part 5: iPhone Cacheability - Making it Stick”</a>.</p><h3 id="Pack-Components-into-a-Multipart-Document"><a href="#Pack-Components-into-a-Multipart-Document" class="headerlink" title="Pack Components into a Multipart Document"></a>Pack Components into a Multipart Document</h3><p>把内容组件打包到一个 multipart 文档，就像带附件的电子邮件, 有助于使用一次 HTTP 请求，获取多个内容组件。使用这个技巧前, 首先检查一下客户端的 user agent 是否支持(iPhone 不支持)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在&lt;a href=&quot;/2017/09/06/高性能Web建设指南摘要&quot;&gt;高性能 Web 建设指南摘要&lt;/a&gt;总结了前端性能优化的 14 条原则，在高性能 Web 进阶指南中，也由一些建议。几年过去了，Yahoo 的 Exceptional Performance team 总结的规则也发展到 35 条。&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;。规则分为七类：页面内容，服务器，cookie，css，javascript，图片和手机端。&lt;br&gt;&amp;emsp;&amp;emsp; 根据原文翻译整理了一下，记录了一些新的原则。感谢前端工具的发展，如 webpack，eslint，其中很多优化原则都可以让工具自动实施。其中原来的黄金规则可参看&lt;a href=&quot;/2017/09/06/高性能Web建设指南摘要&quot;&gt;高性能 Web 建设指南摘要&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="https://chenhx9211.github.io/categories/frontend/"/>
    
    
      <category term="前端性能" scheme="https://chenhx9211.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>高性能Web进阶指南摘要</title>
    <link href="https://chenhx9211.github.io/2017/09/23/%E9%AB%98%E6%80%A7%E8%83%BDWeb%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E6%91%98%E8%A6%81/"/>
    <id>https://chenhx9211.github.io/2017/09/23/高性能Web进阶指南摘要/</id>
    <published>2017-09-23T13:09:11.000Z</published>
    <updated>2019-06-19T10:25:24.327Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本书大部分内容讲 JavsScript 的性能优化，图片和 CSS 的处理也涉及到一些，也涉及到一些服务器端的处理。<br>里面的内容讲得很好，不过鉴于近期的前端框架和工具的成熟，里面绝大内容都由框架和工具自动处理了，就没有摘录。<br>写在这里，不过是为看过这本书做个记录。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本书大部分内容讲 JavsScript 的性能优化，图片和 CSS 的处理也涉及到一些，也涉及到一些服务器端的处理。&lt;br&gt;里面的内容讲得很好，不过鉴于近期的前端框架和工具的成熟，里面绝大内容都由框架和工具自动处理了，就没有摘录。&lt;br&gt;写在这里，不过是为看过这本书做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="https://chenhx9211.github.io/categories/frontend/"/>
    
    
      <category term="前端性能" scheme="https://chenhx9211.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>高性能Web建设指南摘要</title>
    <link href="https://chenhx9211.github.io/2017/09/06/%E9%AB%98%E6%80%A7%E8%83%BDWeb%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97%E6%91%98%E8%A6%81/"/>
    <id>https://chenhx9211.github.io/2017/09/06/高性能Web建设指南摘要/</id>
    <published>2017-09-06T13:09:11.000Z</published>
    <updated>2019-06-19T08:05:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;性能黄金法则：10 ～ 20%的总响应时间在下载 html 文档，80 ～ 90%的时间在下载页面中的组件(图片，外部样式表、脚本等)。优化的要点是减少占比达 80 ～ 90%页面组件响应时间。</p><a id="more"></a><h2 id="规则-1–减少-HTTP-请求"><a href="#规则-1–减少-HTTP-请求" class="headerlink" title="规则 1–减少 HTTP 请求"></a>规则 1–减少 HTTP 请求</h2><p>运用以下技术减少 http 请求</p><ul><li>图片地图</li><li>CSS Sprites</li><li>内联图片</li><li>合并样式表</li><li>合并脚本</li></ul><h2 id="规则-2–使用内容分发网络"><a href="#规则-2–使用内容分发网络" class="headerlink" title="规则 2–使用内容分发网络"></a>规则 2–使用内容分发网络</h2><p>&emsp;&emsp;内容分布网络(CDN)是一组分布在多个不同地理位置的 Web 服务器。静态内容组件发布到 CDN 后，会在多个 Web 服务器都有拷贝，当用户请求内容组件时，CDN 可选择响应时间最短的 Web 服务器(比如离用户最近的服务器)来完成请求。</p><p>&emsp;&emsp;CDN 不但带来更短的响应时间，而且可以缓解自身服务器的压力。</p><h2 id="规则-3–添加-EXpires-头"><a href="#规则-3–添加-EXpires-头" class="headerlink" title="规则 3–添加 EXpires 头"></a>规则 3–添加 EXpires 头</h2><p>&emsp;&emsp;http 数据包分为头(head)和身体(body)两部分，头部可添加 Expires 和 Cache-Control 来影响浏览器的缓存时间。有两种方法可以设置 http 头</p><ul><li>服务器端在响应请求时设置请求的 http 头。</li><li>html 页面通过 meta 标签的 http-equiv 来设定。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＜meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2007 22:33:00 GMT&quot;＞</span><br><span class="line">＜meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=7200&quot;＞</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;http-equiv 相当于 http 的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容。http-equiv 对应的属性值为 content，可设置各个参数的变量值。<br>&emsp;&emsp;客户端(比如 JavaScript 脚本)可以在 HTTP 请求中使用的标准 Cache-Control 指令</p><ul><li>Cache-Control: max-age=&lt;seconds&gt;</li><li>Cache-Control: max-stale[=&lt;seconds&gt;</li><li>Cache-Control: min-fresh=&lt;seconds&gt;</li><li>Cache-control: no-cache</li><li>Cache-control: no-store</li><li>Cache-control: no-transform</li><li>Cache-control: only-if-cached</li></ul><p>&emsp;&emsp;服务器可以在响应中使用的标准 Cache-Control 指令</p><ul><li>Cache-control: must-revalidate</li><li>Cache-control: no-cache</li><li>Cache-control: no-store</li><li>Cache-control: no-transform</li><li>Cache-control: public</li><li>Cache-control: private</li><li>Cache-control: proxy-revalidate</li><li>Cache-Control: max-age=&lt;seconds&gt;</li><li>Cache-control: s-maxage=&lt;seconds&gt;</li></ul><h2 id="规则-4–压缩组件"><a href="#规则-4–压缩组件" class="headerlink" title="规则 4–压缩组件"></a>规则 4–压缩组件</h2><p>Web 客户端可在 http 请求的头部中加入 Accept-Encoding 来标识客户端支持的压缩方法类型（浏览器一般会自动在每次的请求中加入这个头部指令），Web 服务器会用客户端列出来的方法之一来压缩响应结果，并在响应中加入 Content-Encoding:xxx. 最常用的压缩方法是 gzip。</p><ul><li>存在代理和 CDN 的情况会变复杂，解决办法是在服务器的响应头部中加入 Vary: Accept-Encoding</li></ul><h2 id="规则-5–将样式表放在文档顶部"><a href="#规则-5–将样式表放在文档顶部" class="headerlink" title="规则 5–将样式表放在文档顶部"></a>规则 5–将样式表放在文档顶部</h2><p>&emsp;&emsp;浏览器一般会逐步呈现已下载的内容，样式表放在文档底部时，为避免当样式变化时重绘页面中的元素，浏览器会延迟显示任何可视化组件。样式表的放置在底部不会影响下载时间，但是会影响内容的逐步呈现，用户会有更慢的感觉，同时它还和白屏、无样式内容的闪烁相关。</p><h2 id="规则-6–将脚本放在文档底部"><a href="#规则-6–将脚本放在文档底部" class="headerlink" title="规则 6–将脚本放在文档底部"></a>规则 6–将脚本放在文档底部</h2><p>&emsp;&emsp;http 1.1 协议建议浏览器从每个主机名下并行的下载两个组件。 然而，下载脚本时实际上会禁用并行下载-即使使用了不同的主机名。其中的原因是：</p><ul><li>脚本可能使用 document.write 来修改页面内容，因此浏览器会等待，以确保页面能够恰当的布局。</li><li>保证脚本能按正确的顺序执行，如果并行下载多个脚本，页面次序中在后的脚本有可能先下载完成并执行。</li></ul><p>&emsp;&emsp;将脚本放在顶部，会阻塞对其后面内容的呈现，同时阻塞对后面组件的下载。</p><h2 id="规则-7–避免-CSS-表达式"><a href="#规则-7–避免-CSS-表达式" class="headerlink" title="规则 7–避免 CSS 表达式"></a>规则 7–避免 CSS 表达式</h2><p>&emsp;&emsp;CSS expression 方法可接受一个 JavaScript 表达式，很多情况下会导致对其频繁求值，影响浏览器性能。<br>建议使用一次性表达式，或使用 JavaScript 在事件处理中提供动态行为。</p><h2 id="规则-8–使用外部-JavaScript-和-CSS"><a href="#规则-8–使用外部-JavaScript-和-CSS" class="headerlink" title="规则 8–使用外部 JavaScript 和 CSS"></a>规则 8–使用外部 JavaScript 和 CSS</h2><p>&emsp;&emsp;浏览器可以缓存外部 JavaScript 和 CSS，外部的 JavaScript 和 CSS 还可给网站中其他页面共享。</p><ul><li>加载后下载<br>同样的样式表或脚本同时写入到外部文件和内联到页面中，在页面的 onload 事件再次下载含有同样内容的外部文件。内联的样式和脚本让页面呈现更快，同时网站的其他页面可使用已下载的外部样式和脚本文件。需要注意脚本和 CSS 加载两次可能带来的问题。</li></ul><h2 id="规则-9–减少-DNS-查找"><a href="#规则-9–减少-DNS-查找" class="headerlink" title="规则 9–减少 DNS 查找"></a>规则 9–减少 DNS 查找</h2><p>&emsp;&emsp;浏览器会解析 html 页面外部组件所使用主机名称，http 1.1 协议建议每个主机名称两个并行下载；因而在 html 页面中对页面中的组件使用多个主机名称，可提高并行下载数量。然而过多的主机名称，可能不能更好的利用 http 1.1 协议的 keep-alive 特性，同时导致浏览器进行多次 DNS 查找。综合两个考虑，建议在页面中使用至少两个，但不要超过 4 个主机名。</p><h2 id="规则-10–精简（minify）-JavaScript-、-CSS"><a href="#规则-10–精简（minify）-JavaScript-、-CSS" class="headerlink" title="规则 10–精简（minify） JavaScript 、 CSS"></a>规则 10–精简（minify） JavaScript 、 CSS</h2><p>压缩混淆 JavaScript 代码，以减小代码尺寸。同样对 CSS，html 都可使用工具进行 minify。</p><h2 id="规则-11–避免重定向"><a href="#规则-11–避免重定向" class="headerlink" title="规则 11–避免重定向"></a>规则 11–避免重定向</h2><p>一些容易忽视的场景：</p><ul><li>url 指向目录时，结尾不要省略斜线/，不要让 Web 服务器为你发出重定向</li><li>内部流量跟踪，使用 referer 日志跟踪流量取向，而不是使用重定向。</li><li>出战流量跟踪，不实用重定向，而使用信标 beancon–一个在 url 中包含有跟踪信息的 http 请求（信标响应通常是一个 1px X 1px 的透明图片；或者使用 204 响应，因为它更小，从来不会被缓存，而且绝对不会改变浏览器状态。），跟踪信息可以从信标的 web 服务器请求日志中提取出来。</li></ul><p>&emsp;&emsp;使用图片的信标例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://en.wikipedia.org/wiki/Performance&quot;</span><br><span class="line">   onclick=&quot;resultBeacon(this); return false;&quot;&gt;Performance - Wikipedia&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var beacon;</span><br><span class="line">function resultBeacon(anchor) &#123;</span><br><span class="line">    beacon = new Image();</span><br><span class="line">    beacon.onload = gotoUrl;</span><br><span class="line">    beacon.onerror = gotoUrl;  // in case the image fails, we still want to redirect the user</span><br><span class="line">  beacon.anchor = anchor;</span><br><span class="line">    beacon.src = &quot;/bin/beacon204.gif?url=&quot; + escape(anchor.href);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function gotoUrl() &#123;</span><br><span class="line">    document.location = beacon.anchor.href;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用 XHttpRequest 的信标例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://en.wikipedia.org/wiki/Performance&quot;</span><br><span class="line">   onclick=&quot;resultBeacon(this); return false;&quot;&gt;Performance - Wikipedia&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gAnchor, gXhrObj;</span><br><span class="line"></span><br><span class="line">function resultBeacon(anchor) &#123;</span><br><span class="line">gAnchor = anchor;</span><br><span class="line">  beacon_src = &quot;http://stevesouders.com/images/beacon.gif?url=&quot; + escape(anchor.href) + &quot;&amp;t=&quot; + Number(new Date());</span><br><span class="line"></span><br><span class="line">gXhrObj = getXHRObject();</span><br><span class="line">gXhrObj.onreadystatechange = xhrCallback;</span><br><span class="line">try &#123;</span><br><span class="line">gXhrObj.open(&quot;GET&quot;, beacon_src, true);  // true == async</span><br><span class="line">gXhrObj.send(&quot;&quot;);</span><br><span class="line">&#125;catch(err) &#123;</span><br><span class="line">gotoUrl();  // on failure, just go to the target url</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function xhrCallback(respAr) &#123;</span><br><span class="line">    var readyState = ( respAr &amp;&amp; &quot;undefined&quot; != typeof(respAr.readyState) ? respAr.readyState : gXhrObj.readyState );</span><br><span class="line">    if ( 2 == readyState ) &#123;    // the request is done enough to risk unloading the page</span><br><span class="line">        gotoUrl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function gotoUrl() &#123;</span><br><span class="line">    document.location = gAnchor.href;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Find the right syntax for creating an XHR object.</span><br><span class="line">function getXHRObject() &#123;</span><br><span class="line">    var xhrObj = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        xhrObj = new XMLHttpRequest();</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        var progid = [&apos;MSXML2.XMLHTTP.5.0&apos;, &apos;MSXML2.XMLHTTP.4.0&apos;, &apos;MSXML2.XMLHTTP.3.0&apos;, &apos;MSXML2.XMLHTTP&apos;, &apos;Microsoft.XMLHTTP&apos;];</span><br><span class="line">        for ( var i=0; i &lt; progid.length; ++i ) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                xhrObj = new ActiveXObject(progid[i]);</span><br><span class="line">            &#125;catch(e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        return xhrObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="规则-12–移除重复脚本"><a href="#规则-12–移除重复脚本" class="headerlink" title="规则 12–移除重复脚本"></a>规则 12–移除重复脚本</h2><p>&emsp;&emsp;团队规模和脚本数量变大，往往会有相同的脚本代码。需要实现一个脚本管理模块，避免重复的脚本。</p><h2 id="规则-13–配置或移除-ETag"><a href="#规则-13–配置或移除-ETag" class="headerlink" title="规则 13–配置或移除 ETag"></a>规则 13–配置或移除 ETag</h2><p>&emsp;&emsp;ETag，Entity Tag-实体标签是 Web 服务器和浏览器用于确认缓存组件有效性的一种机制。条件 Get 请求会比较文件修改日期和 ETag 标签，ETag 标签对于静态文件而言不利。因此建议是在服务器端配置 ETag 或者干脆移除它。</p><h2 id="规则-14–使-AJAX-可缓存"><a href="#规则-14–使-AJAX-可缓存" class="headerlink" title="规则 14–使 AJAX 可缓存"></a>规则 14–使 AJAX 可缓存</h2><p>&emsp;&emsp;某些 AJAX Get 请求可以被缓存，而不影响用户体验。要使这些 AJAX 请求被缓存，需要</p><ul><li>给响应设置 HTTP Cache-Control 或 Expires 头</li><li>请求的 URL 中应包括响应的个性化和动态化数据，这样缓存结果才正确的反映出个性化和动态化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;性能黄金法则：10 ～ 20%的总响应时间在下载 html 文档，80 ～ 90%的时间在下载页面中的组件(图片，外部样式表、脚本等)。优化的要点是减少占比达 80 ～ 90%页面组件响应时间。&lt;/p&gt;
    
    </summary>
    
      <category term="frontend" scheme="https://chenhx9211.github.io/categories/frontend/"/>
    
    
      <category term="前端性能" scheme="https://chenhx9211.github.io/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://chenhx9211.github.io/2017/09/06/%E9%97%AD%E5%8C%85/"/>
    <id>https://chenhx9211.github.io/2017/09/06/闭包/</id>
    <published>2017-09-06T13:09:11.000Z</published>
    <updated>2019-06-19T14:35:32.985Z</updated>
    
    <content type="html"><![CDATA[<p>闭包 = 函数 + 函数能够访问的自由变量</p><a id="more"></a><h2 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h2><p>&emsp;&emsp;自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量，也称为未绑定变量(unbound)。相对而言，参数和局部变量就是绑定变量。</p><p>&emsp;&emsp;举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。</p><h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h2><p>&emsp;&emsp;了解了自由变量，闭包的定义就很好理解：闭包是指那些能够访问自由变量的函数。<br>&emsp;&emsp;从理论角度：所有的 JavaScript 函数都是闭包。因为它们都在创建的时候就将上层上下文的数据保存起来了, 在函数中访问全局变量就相当于是在访问自由变量。<br>&emsp;&emsp;从实践角度：以下函数才算是闭包：</p><ul><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ul><p>&emsp;&emsp;JavaScript 权威指南对闭包的定义是:<br>&emsp;&emsp;闭包就是一个函数对象和一个作用域(scope, a set of variable bindings，在这个作用域中，该函数的所有变量都能查找到)的结合，</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>来自《JavaScript 权威指南》的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p><ol><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li><li>全局执行上下文初始化</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this 等</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li><li>f 执行上下文初始化，创建变量对象、作用域链、this 等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ol><p>&emsp;&emsp;当 f 函数执行的时候，checkscope 函数上下文已经从执行上下文栈中被弹出被销毁，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p><p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">  Scope: [AO, checkscopeContext.AO, globalContext.VO]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即使 checkscopeContext 被销毁了，当 f 函数引用了 checkscopeContext.VO 中的值的时候， JavaScript 依然会让 checkscopeContext.VO 保持在内存中，f 函数依然可以通过 f 函数的作用域链找到它，实现了闭包。</p><p>面试必考的闭包题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>答案是都是 3，让我们分析一下原因：</p><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。</p><p>data[1] 和 data[2] 是一样的道理。</p><p>改成下面的代码看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟没改之前一模一样。</p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数执行上下文的 AO 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">      length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    i: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为 3)，所以打印的结果就是 0。</p><p>data[1] 和 data[2] 是一样的道理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包 = 函数 + 函数能够访问的自由变量&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://chenhx9211.github.io/categories/javascript/"/>
    
    
      <category term="闭包" scheme="https://chenhx9211.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>执行上下文和作用域链</title>
    <link href="https://chenhx9211.github.io/2017/09/06/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>https://chenhx9211.github.io/2017/09/06/执行上下文和作用域链/</id>
    <published>2017-09-06T13:09:11.000Z</published>
    <updated>2019-06-19T14:14:37.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>&emsp;&emsp;JavaScript 引擎执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。JavaScript 引擎创建执行上下文栈（Execution context stack，ECStack）来管理执行上下文。</p><a id="more"></a><p>&emsp;&emsp;JavaScript 引擎 开始要解释执行代码的时候，最先遇到的就是全局代码，初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：<br>&emsp;&emsp;执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。</p><p>看一个《JavaScript 权威指南》中的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>两段代码执行的结果一样，但是两段代码的是执行上下文栈的变化不一样。</p><p>第一段代码的执行过程模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>第二段代码的执行过程模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>&emsp;&emsp;作用域是指程序代码中定义变量的区域，它规定了如何查找变量。 一个变量写在函数中，和写在函数外，它的作用域是不同的，也就是所谓局部变量和全局变量。<br>&emsp;&emsp;在编程语言的设计中，有两种作用域设计方式：静态作用域与动态作用域。JavaScript 采用的是静态作用域。</p><ul><li>静态作用域，也叫词法作用域(lexical scoping)，函数的作用域在函数定义的时候就决定了。</li><li>动态作用域，函数的作用域是在函数调用的时候才决定的。</li></ul><p>&emsp;&emsp;举看个例子来说明它们直接的之间的区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设 JavaScript 采用静态作用域， foo 函数的执行，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据定义的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p><p>&emsp;&emsp;假设 JavaScript 采用动态作用域，foo 函数的执行，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用 foo()的位置所在的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p><p>&emsp;&emsp;JavaScript 采用的是静态作用域，这个例子的结果是 1。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)，包含了全部的局部变量</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>&emsp;&emsp;JavaScript 代码执行时，先从当前上下文中查找变量，如果没有找到，就从父级(词法层面上的父级)执行上下文的变量对象 VO 中查找，一直找到全局上下文的变量对象，也就是全局对象。这样，多个执行上下文的变量对象就构成一个链表，叫做作用域链。<br>&emsp;&emsp;和作用域一样，JavaScript 函数的作用域链是在函数定义的时候创建的。当函数创建的时候，有一个内部属性 [[scope]]，会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是[[scope]] 并不代表完整的作用域链。当函数执行时，创建活动对象 AO；再将活动对象 AO 添加到作用链的前端。这时候执行上下文的作用域链，才是完整的，我们命名为 Scope：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>结合 ECStack，再来看看上面的列出的《JavaScript 权威指南》中例子的第一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><ol><li>执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [globalContext];</span><br></pre></td></tr></table></figure><p>全局上下文初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">  VO: [global, scope, checkscope],</span><br><span class="line">  Scope: [globalContext.VO],</span><br><span class="line">  <span class="keyword">this</span>: globalContext.VO</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol start="3"><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化 checkscope 函数执行上下文：</li></ol><ul><li><p>复制函数 [[scope]] 属性创建作用域链，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 arguments 创建活动对象</p></li><li><p>初始化活动对象，加入形参、函数声明、变量声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope: <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>将活动对象压入 checkscope 作用域链顶端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope: <span class="literal">undefined</span>,</span><br><span class="line">        f: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, globalContext.VO],</span><br><span class="line">    <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>开始执行函数，随着函数的执行，修改 AO 的属性值，AO 中的 scope 被赋值”local scope”</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope: <span class="string">"local scope"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [fContext, checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure><p>6.f 函数执行上下文初始化, 以下跟第 4 步相同：</p><ul><li>复制函数 [[scope]] 属性创建作用域链</li><li>用 arguments 创建活动对象</li><li>初始化活动对象，即加入形参、函数声明、变量声明</li><li>将活动对象压入 f 作用域链顶端</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">  <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</p><p>8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure><p>9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [globalContext];</span><br></pre></td></tr></table></figure><p>同样可分析第二段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;执行上下文&quot;&gt;&lt;a href=&quot;#执行上下文&quot; class=&quot;headerlink&quot; title=&quot;执行上下文&quot;&gt;&lt;/a&gt;执行上下文&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;JavaScript 引擎执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。JavaScript 引擎创建执行上下文栈（Execution context stack，ECStack）来管理执行上下文。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://chenhx9211.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>react-native 常用的布局：flexbox</title>
    <link href="https://chenhx9211.github.io/2017/07/10/layout/"/>
    <id>https://chenhx9211.github.io/2017/07/10/layout/</id>
    <published>2017-07-10T06:09:14.000Z</published>
    <updated>2019-06-19T11:22:14.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>采用 flex 布局的元素就是 flex 容器：flex container.它里面所有的元素都叫子元素：flex item.</li><li>container 容器存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis).主轴起始位置 main start,结束位置 main end,交叉轴起始位置 cross start,结束位置 cross end. 3.项目默认沿着主轴排列.</li></ol><a id="more"></a><h3 id="container-上设置的属性有-6-个"><a href="#container-上设置的属性有-6-个" class="headerlink" title="container 上设置的属性有 6 个"></a>container 上设置的属性有 6 个</h3><ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><h3 id="flex-direction-主轴的方向"><a href="#flex-direction-主轴的方向" class="headerlink" title="flex-direction:主轴的方向"></a>flex-direction:主轴的方向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    flex-direction:row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-wrap-如果一条轴线排不下，如何换行"><a href="#flex-wrap-如果一条轴线排不下，如何换行" class="headerlink" title="flex-wrap:如果一条轴线排不下，如何换行"></a>flex-wrap:如果一条轴线排不下，如何换行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.nowrap:不换行<br>2.wrap：换行，第一行在上方<br>3.wrap-reverse：换行，第一行在下方</p><h3 id="flex-flow：是-flex-direction-和-flex-wrap-的简写"><a href="#flex-flow：是-flex-direction-和-flex-wrap-的简写" class="headerlink" title="flex-flow：是 flex-direction 和 flex-wrap 的简写"></a>flex-flow：是 flex-direction 和 flex-wrap 的简写</h3><h3 id="justify-content：项目在主轴上的对齐方式"><a href="#justify-content：项目在主轴上的对齐方式" class="headerlink" title="justify-content：项目在主轴上的对齐方式"></a>justify-content：项目在主轴上的对齐方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>flex-start：左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目之间的间隔都相等</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ol><h3 id="align-items：项目在交叉轴上如何对齐"><a href="#align-items：项目在交叉轴上如何对齐" class="headerlink" title="align-items：项目在交叉轴上如何对齐"></a>align-items：项目在交叉轴上如何对齐</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>flex-start：交叉轴的起点对齐</li><li>flex-end：交叉轴的终点对齐</li><li>center：交叉轴的中点对齐</li><li>baseline：项目的第一行文字的基线对齐</li><li>stretch：如果项目未设置高度或设为 auto，将占满整个容器的高度(默认值)</li></ol><h3 id="align-content-定义了多根轴线的对齐方式-如果项目只有一根轴线，该属性不起作用"><a href="#align-content-定义了多根轴线的对齐方式-如果项目只有一根轴线，该属性不起作用" class="headerlink" title="align-content:定义了多根轴线的对齐方式.如果项目只有一根轴线，该属性不起作用"></a>align-content:定义了多根轴线的对齐方式.如果项目只有一根轴线，该属性不起作用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="item-上设置的属性有-6-个"><a href="#item-上设置的属性有-6-个" class="headerlink" title="item 上设置的属性有 6 个"></a>item 上设置的属性有 6 个</h3><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><h3 id="order-定义项目的排列顺序-数值越小，排列越靠前，默认为-0"><a href="#order-定义项目的排列顺序-数值越小，排列越靠前，默认为-0" class="headerlink" title="order:定义项目的排列顺序.数值越小，排列越靠前，默认为 0."></a>order:定义项目的排列顺序.数值越小，排列越靠前，默认为 0.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;<span class="built_in">integer</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-grow-定义项目的放大比例，默认为-0，即如果存在剩余空间，也不放大"><a href="#flex-grow-定义项目的放大比例，默认为-0，即如果存在剩余空间，也不放大" class="headerlink" title="flex-grow:定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大."></a>flex-grow:定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大.</h3><p>注意：如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">   flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-shrink：定义了项目的缩小比例，默认为-1，即如果空间不足，该项目将缩小"><a href="#flex-shrink：定义了项目的缩小比例，默认为-1，即如果空间不足，该项目将缩小" class="headerlink" title="flex-shrink：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小."></a>flex-shrink：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小.</h3><p>注意：如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">   flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main-size）"><a href="#flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main-size）" class="headerlink" title="flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）."></a>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）.</h3><p>注意：它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">   flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex：是-flex-grow-flex-shrink-和-flex-basis-的简写，默认值为-0-1-auto。后两个属性可选"><a href="#flex：是-flex-grow-flex-shrink-和-flex-basis-的简写，默认值为-0-1-auto。后两个属性可选" class="headerlink" title="flex：是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选."></a>flex：是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选.</h3><h3 id="align-self-允许单个项目有与其他项目不一样的对齐方式，可覆盖-align-items-属性-默认值为-auto"><a href="#align-self-允许单个项目有与其他项目不一样的对齐方式，可覆盖-align-items-属性-默认值为-auto" class="headerlink" title="align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性.默认值为 auto."></a>align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性.默认值为 auto.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">   align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦,到此结束！</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>任何一个元素都可以使用 flex 布局，行内元素使用 display:inline-flex;</li><li>webkit 内核的浏览器必须加上-webkit 前缀：display：-webkit-flex;</li><li>设置 flex 布局以后，子元素的这三个属性将会失效:float,clear,vertical-align.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;采用 flex 布局的元素就是 flex 容器：flex container.它里面所有的元素都叫子元素：flex item.&lt;/li&gt;
&lt;li&gt;container 容器存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis).主轴起始位置 main start,结束位置 main end,交叉轴起始位置 cross start,结束位置 cross end. 3.项目默认沿着主轴排列.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="frontend" scheme="https://chenhx9211.github.io/categories/frontend/"/>
    
    
      <category term="flex" scheme="https://chenhx9211.github.io/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>继承的多种方式</title>
    <link href="https://chenhx9211.github.io/2016/09/15/%E5%A4%9A%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>https://chenhx9211.github.io/2016/09/15/多种继承方式/</id>
    <published>2016-09-15T13:09:11.000Z</published>
    <updated>2019-06-19T12:31:46.913Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 各种继承方式和优缺点。</p><a id="more"></a><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"kevin"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><p>问题：</p><p>1.引用类型的属性被所有实例共享，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">"kevin"</span>, <span class="string">"daisy"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">"yayu"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br></pre></td></tr></table></figure><p>2.在创建 Child 的实例时，不能向 Parent 传参</p><h2 id="2-借用构造函数-经典继承"><a href="#2-借用构造函数-经典继承" class="headerlink" title="2.借用构造函数(经典继承)"></a>2.借用构造函数(经典继承)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">"kevin"</span>, <span class="string">"daisy"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">"yayu"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy"]</span></span><br></pre></td></tr></table></figure><p>优点：</p><p>1.避免了引用类型的属性被所有实例共享</p><p>2.可以在 Child 中向 Parent 传参</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">"kevin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">"daisy"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br></pre></td></tr></table></figure><p>缺点：</p><p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><p>原型链继承和经典继承双剑合璧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">"kevin"</span>, <span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">"daisy"</span>, <span class="string">"20"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p><p>缺点：</p><p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"kevin"</span>,</span><br><span class="line">  friends: [<span class="string">"daisy"</span>, <span class="string">"kelly"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"person1"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">"taylor"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure><p>注意：修改<code>person1.name</code>的值，<code>person2.name</code>的值并未发生改变，并不是因为<code>person1</code>和<code>person2</code>有独立的 name 值，而是因为<code>person1.name = &#39;person1&#39;</code>，给<code>person1</code>添加了 name 值，并非修改了原型上的 name 值。</p><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object.create(o);</span><br><span class="line">  clone.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><p>为了方便大家阅读，在这里重复一下组合继承的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">"kevin"</span>, <span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点是会调用两次父构造函数。</p><p>一次是设置子类型实例的原型的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>一次在创建子类型实例的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">"kevin"</span>, <span class="string">"18"</span>);</span><br></pre></td></tr></table></figure><p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(<span class="keyword">this</span>, name);</span><br></pre></td></tr></table></figure><p>在这里，我们又会调用了一次 Parent 构造函数。</p><p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]</code>。</p><p>那么我们该如何精益求精，避免这一次重复调用呢？</p><p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p><p>看看如何实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">"kevin"</span>, <span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure><p>最后我们封装一下这个继承方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">  prototype.constructor = child;</span><br><span class="line">  child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><p>引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是：</p><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 各种继承方式和优缺点。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://chenhx9211.github.io/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>原型和原型链</title>
    <link href="https://chenhx9211.github.io/2016/07/02/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://chenhx9211.github.io/2016/07/02/原型和原型链/</id>
    <published>2016-07-02T03:29:07.000Z</published>
    <updated>2019-06-19T12:31:08.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">"Kevin"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><p>很简单吧，接下来进入正题：</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 虽然写在注释里，但是你要注意：</span></span><br><span class="line"><span class="comment">// prototype是函数才会有的属性</span></span><br><span class="line">Person.prototype.name = <span class="string">"Kevin"</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的<strong>实例</strong>的原型，也就是这个例子中的 person1 和 person2 的原型。</p><p>那什么是原型呢？你可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p><p>让我们用一张图表示构造函数和实例原型之间的关系：</p><p><img src="/images/prototype1.png" alt="构造函数和实例原型的关系图"></p><p>在这张图中我们用 Object.prototype 表示实例原型。</p><p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p><p>为了证明这一点,我们可以在火狐或者谷歌中输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>于是我们更新下关系图：</p><p><img src="/images/prototype2.png" alt="实例与实例原型的关系图"></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor﻿，每个原型都有一个 constructor 属性指向关联的构造函数。</p><p>为了验证这一点，我们可以尝试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以再更新下关系图：</p><p><img src="/images/prototype3.png" alt="实例原型与构造函数的关系图"></p><p>综上我们已经得出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系：</p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Kevin"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"Daisy"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">"Kevin"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图：</p><p><img src="/images/prototype4.png" alt="原型的原型关系图"></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p><p>null，我们可以打印：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>然而 null 究竟代表了什么呢？</p><p>引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">《undefined 与 null 的区别》</a> 就是：</p><blockquote><p>null 表示“没有对象”，即该处不应该有值。</p></blockquote><p>所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p><p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p><p>最后一张关系图也可以更新为：</p><p><img src="/images/prototype5.png" alt="原型链示意图"></p><p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最后，补充三点大家可能不会注意的地方：</p><h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><p>首先是 constructor 属性，我们看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor;</span><br></pre></td></tr></table></figure><h3 id="proto-1"><a href="#proto-1" class="headerlink" title="__proto__"></a>__proto__</h3><p>其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构造函数创建对象&quot;&gt;&lt;a href=&quot;#构造函数创建对象&quot; class=&quot;headerlink&quot; title=&quot;构造函数创建对象&quot;&gt;&lt;/a&gt;构造函数创建对象&lt;/h2&gt;&lt;p&gt;我们先使用构造函数创建一个对象：&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="javascript" scheme="https://chenhx9211.github.io/categories/javascript/"/>
    
    
      <category term="原型" scheme="https://chenhx9211.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript代码的解释和执行</title>
    <link href="https://chenhx9211.github.io/2016/04/20/JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%92%8C%E6%89%A7%E8%A1%8C/"/>
    <id>https://chenhx9211.github.io/2016/04/20/JavaScript代码的解释和执行/</id>
    <published>2016-04-20T13:09:11.000Z</published>
    <updated>2019-06-19T12:30:11.774Z</updated>
    
    <content type="html"><![CDATA[<p>当函数执行的时候，执行上下文栈、变量对象、作用域链如何变化。</p><a id="more"></a><p>&emsp;&emsp;比较两段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo1"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// foo1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo2"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p>打印的结果却是两个 <code>foo2</code>。</p><p>JavaScript 引擎并非一行一行地分析解释和执行代码，而是先把整段代码分析解释完成后再执行。分析代码时，如果有重复函数的定义，前面的定义会被后面的覆盖。上面的代码中，第一段代码函数定义采用匿名方式，第二段代码命名函数 foo 的定义，前者被后者覆盖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当函数执行的时候，执行上下文栈、变量对象、作用域链如何变化。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://chenhx9211.github.io/categories/javascript/"/>
    
    
  </entry>
  
</feed>
